module toJsAST/expressions

imports 
	signatures/-
	signatures/spoofaxJS-sig
	signatures/MethodDecl-sig
	signatures/Parameter-sig
	signatures/Statement-sig
	signatures/Expression-sig
	signatures/Common-sig
	trans/pp
	helpers
	toJsAST/statements
	toJsAST/declarations
	toJsAST/channelhelper
		
rules
	//ExpressionList([UnaryExpr(PrimaryExpr(Operand(Literal(IntLit("10")))))])
	gen-js-ast:
		UnaryExpr(unaryExpression) -> <gen-js-ast> unaryExpression
	
	gen-js-ast:
		PrimaryExpr(primaryExpression) -> <gen-js-ast> primaryExpression
	
	gen-js-ast:
		PrimaryExprArguments(
			Operand(OperandName("println")),
			args
		) -> Call(Property(Identifier("console"), "log"), argsJs)
		where
			argsJs := <gen-js-ast> args

	gen-js-ast:
		PrimaryExprArguments(
			Operand(OperandName("make")),
			TypeArgWithList(Channel(_), 
				args
            )
		) -> Call(Property(Identifier(GOROUTINE_LIBNAME), GOROUTINE_MAKECHANNELMETHOD), argsJs)
		where
			argsJs := <gen-js-ast> Arguments(Some(args))
			
			
	gen-js-ast:
		PrimaryExprArguments(
			Operand(OperandName("make")),
			TypeArg(Channel(_))
		) -> Call(Property(Identifier(GOROUTINE_LIBNAME), GOROUTINE_MAKECHANNELMETHOD), [IntegerLiteral("0")])
	
	// If the target is an operand, make a JS function call
	gen-js-ast:
		PrimaryExprArguments(
			Operand(
				OperandName(target)
			),
			args
		) -> Call(target, argsJs)
		where
			argsJs := <gen-js-ast> args
	
	gen-js-ast:
		PrimaryExprIndex(
			idExp,
			Index(indexExp)
		) ->  Array(Call(Property(idExpjs, ARRAYLIB_LOOKUPMETHOD), [indexExpJs]), [indexExpJs])
		with
			idExpjs := <gen-js-ast> idExp;
			indexExpJs := <gen-js-ast> indexExp
	
	// If the target is a primary expression, make a JS method call
	
	gen-js-ast:
		Channel(
			UnaryExpr(
				x
			)
		) -> <gen-js-ast> x
	
	gen-js-ast:
		PrimaryExprArguments(
			Operand(
				MethodExpr(
					TypeName(receiver),
					methodName
				)
			),
			args
		) -> Call(Property(Identifier(receiver), methodName), argsJs)
		where
			argsJs := <gen-js-ast> args
	
	gen-js-ast:
		PrimaryExprArguments(
			Operand(
				Literal(functionLit)
			),
			args
		) -> Call(Parenthesised(functionJs), argsJs)
		where
			functionJs := <gen-js-ast> functionLit;
			argsJs := <gen-js-ast> args

	gen-js-ast:
		Arguments(
			ExpressionList(args)
		) -> <map(gen-js-ast)> args

	gen-js-ast:
		Arguments(
			Some(ExpressionList(args))
		) -> <map(gen-js-ast)> args
	
	gen-js-ast:
		Arguments(
			None()
		) -> []

	gen-js-ast:
		Operand(operand) -> <gen-js-ast> operand


	gen-js-ast: SubstitutedExp(exp, stmtlist, lastvar) -> <gen-js-ast> exp
	
	gen-js-ast:
		OperandName(name) -> Identifier(name)

	gen-js-ast:
		Literal(literal) -> <debug(!"LIT"); gen-js-ast> literal

	gen-js-ast: IntLit(int) -> String(int)
	gen-js-ast: StringLit(string) -> String(string)

	gen-js-ast: CompositeLit(ArrayType(sizeExp, type), arrayLit) -> 
				Call(Property(Identifier(ARRAYLIB_NAME), ARRAYLIB_NEWARRAYMETHOD), [ 
						  arrayLitJs
	            		, sizeExpJs
	            		, String(typeJs)
            		]
          		)
		with
			sizeExpJs := <gen-js-ast> sizeExp;
			//TODO: Type to JS
			typeJs := "''";
			arrayLitJs := <array-to-js> arrayLit
	
	array-to-js: LiteralValue(Some(ElementList(x))) -> ArrayLiteral(<map(gen-js-ast)> x)	
	array-to-js: LiteralValue(None()) -> ArrayLiteral([]) 	

	gen-js-ast: FunctionLit(function) -> <gen-js-ast> function
	gen-js-ast: SingleElem(exp) -> <gen-js-ast> exp


	gen-js-ast:
		Function(
			Signature(Parameters(params), returnType),
			FunctionBody(block)
		) -> AnonFunction(paramsJs, bodyJs)
		where
			<debug(!"Found anonymous function with parameters ")> <write-to-string> params;
			paramsJs := <map(gen-js-ast)> params;
			bodyJs := <func-block> block		