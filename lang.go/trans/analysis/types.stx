module analysis/types

imports
  analysis/signatures
  // signatures/Blocks-sig
  // signatures/Declarations-sig
  // signatures/Expressions-sig
  // signatures/GoLang-sig
  // signatures/Lexical-sig
  // signatures/Packages-sig
  // signatures/Representation-sig
  // signatures/SortNames-sig
  // signatures/Statements-sig
  // signatures/Types-sig

imports
  analysis/expressions
  analysis/util

signature
sorts TYPE

// Special types
constructors
  NAMED       : occurrence -> TYPE
  FUN         : list(TYPE) * TYPE -> TYPE
  ARRAY       : int * TYPE -> TYPE
  SLICE       : TYPE -> TYPE
  STRUCT      : scope -> TYPE
  PTR         : TYPE -> TYPE
  MAP         : TYPE * TYPE -> TYPE
  // A TUPLE type, to model Go functions with multiple return values.
  // Note that tuples don't have first-class support in Go. For example,
  // you cannot nest tuples. But this way we can distinguish between the case
  // of a function with zero, one, and multiple return values.
  // Invariants: empty and singleton tuples are not allowed; nested tuples are not allowed.
  TUPLE       : list(TYPE) -> TYPE
  // A VOID type, to model Go functions with no return value.
  VOID        : TYPE

// Untyped constant types
constructors
  UNTYPED_INT       : TYPE
  UNTYPED_BOOL      : TYPE
  UNTYPED_RUNE      : TYPE
  UNTYPED_FLOAT     : TYPE
  UNTYPED_COMPLEX   : TYPE
  UNTYPED_STRING    : TYPE

// Built-in types
constructors
  BOOL        : TYPE
  STRING      : TYPE

  UINT        : TYPE
  UINT8       : TYPE    // BYTE
  UINT16      : TYPE
  UINT32      : TYPE
  UINT64      : TYPE
  UINTPTR     : TYPE

  INT         : TYPE
  INT8        : TYPE
  INT16       : TYPE
  INT32       : TYPE    // RUNE
  INT64       : TYPE
  INTPTR      : TYPE

  FLOAT64     : TYPE
  FLOAT128    : TYPE

  COMPLEX64   : TYPE
  COMPLEX128  : TYPE

signature
  relations
    typeOfDecl : occurrence -> TYPE
  namespaces
    Type : string
    Pkg : string
  name-resolution
    labels P IMP PUB PRV FM
    // TODO: Is this correct?
    resolve Type filter P* (IMP? PUB? PUB? | PRV?) FM* min $ < P, P < PRV, P < PUB, P < FM


rules typeOfType : scope * Type -> TYPE

  typeOfType(s, TypeName2Type(TypeName(name))) = T :-
    lookupType(s, name) == T.

  typeOfType(s, TypeName2Type(QualifiedTypeName(QualifiedIdent(x, y)))) = T :-
    // TODO
    false | error $[typeOfType(QualifiedTypeName) not implemented.].

  typeOfType(s, PointerType(type)) = PTR(T) :-
    typeOfType(s, type) == T.

  typeOfType(s, ArrayType(lengthExpr, type)) = ARRAY(/* dummy size */ 42, T) :-
    // TODO: Evaluate constant expression lengthExpr to an int
    typeOfType(s, type) == T.

  typeOfType(s, SliceType(type)) = SLICE(T) :-
    typeOfType(s, type) == T.

  typeOfType(s, StructType(elements)) = T :-
    // TODO
    false | error $[typeOfType(StructType) not implemented.].

  typeOfType(s, FunctionType(sig)) = TFUN :-
    typeOfSignature(s, sig) == TFUN.

  typeOfType(s, InterfaceType(members)) = T :-
    // TODO
    false | error $[typeOfType(InterfaceType) not implemented.].

  typeOfType(s, MapType(keyType, elementType)) = MAP(TKEY, TELEMENT) :-
    typeOfType(s, keyType) == TKEY,
    typeOfType(s, elementType) == TELEMENT.

  typeOfType(s, BidirectionalChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(BidirectionalChannelType) not implemented.].

  typeOfType(s, SendingChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(SendingChannelType) not implemented.].

  typeOfType(s, ReceivingChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(ReceivingChannelType) not implemented.].


rules typeOfStructElement : scope * StructElement -> TYPE

  // TODO


rules typeOfSignature : scope * Signature -> TYPE

  typeOfSignature(s, Signature(parameters, result)) = FUN(TPARAMS, TRES) :-
    typesOfParameters(s, parameters) == TPARAMS,
    typeOfResult(s, result) == TRES.


rules typeOfResult : scope * Result -> TYPE

  typeOfResult(s, NoResult()) = VOID.

  typeOfResult(s, Parameters2Result(parameters)) = TUPLE(TRES) :-
    typesOfParameters(s, parameters) == TRES.

  typeOfResult(s, Type2Result(type)) = T :-
    typeOfType(s, type) == T.


rules typesOfParameters : scope * Parameters -> list(TYPE)

  typesOfParameters(s, Parameters(parameterDecls)) = TS :-
    typesOfParameterDecls(s, parameterDecls) == TS.


rules typeOfParameterDecl : scope * ParameterDecl -> TYPE

  typesOfParameterDecls maps typeOfParameterDecl(*, list(*)) = list(*)

  typeOfParameterDecl(s, ParameterDecl(_, type)) = T :-
    typeOfType(s, type) == T.

  typeOfParameterDecl(s, VariadicParameterDecl(_, type)) = T :-
    // TODO
    false | error $[typeOfParameterDecl(VariadicParameterDecl) not implemented.].


rules typeOfInterfaceTypeMember : scope * InterfaceTypeMember -> TYPE

  typeOfInterfaceTypeMember(s, MethodSpec(name, sig)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(MethodSpec) not implemented.].

  typeOfInterfaceTypeMember(s, EmbeddedInterface(typeName)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(EmbeddedInterface) not implemented.].


rules isUntypedType : TYPE

  isUntypedType(UNTYPED_INT()).
  isUntypedType(UNTYPED_BOOL()).
  isUntypedType(UNTYPED_RUNE()).
  isUntypedType(UNTYPED_FLOAT()).
  isUntypedType(UNTYPED_COMPLEX()).
  isUntypedType(UNTYPED_STRING()).

rules isComparable : TYPE

  // booleans
  // integers
  // floating-point
  // complex values
  // string values
  // pointers
  // channels
  // interfaces
  // a value x : non-interface X and value t : interface T iff values of type X are comparable and X implements T.
  // struct iff all their fields are comparable
  // array iff array element type is comparable
  isComparable(UNTYPED_INT()).
  isComparable(UNTYPED_BOOL()).
  isComparable(UNTYPED_RUNE()).
  isComparable(UNTYPED_FLOAT()).
  isComparable(UNTYPED_COMPLEX()).
  isComparable(UNTYPED_STRING()).

  isComparable(BOOL()).
  isComparable(STRING()).

  isComparable(UINT()).
  isComparable(UINT8()).
  isComparable(UINT16()).
  isComparable(UINT32()).
  isComparable(UINT64()).
  isComparable(UINTPTR()).

  isComparable(INT()).
  isComparable(INT8()).
  isComparable(INT16()).
  isComparable(INT32()).
  isComparable(INT64()).
  isComparable(INTPTR()).

  isComparable(FLOAT64()).
  isComparable(FLOAT128()).

  isComparable(COMPLEX64()).
  isComparable(COMPLEX128()).

  // TODO: Channels
  // TODO: interfaces
  // TODO: structs iff all their fields are comparable

  isComparable(ARRAY(_, T)) :-
    isComparable(T).

rules isComparableTo : TYPE * TYPE

  isComparableTo(UNTYPED_INT(), UNTYPED_INT()).
  isComparableTo(UNTYPED_INT(), UINT()).
  isComparableTo(UNTYPED_INT(), UINT8()).
  isComparableTo(UNTYPED_INT(), UINT16()).
  isComparableTo(UNTYPED_INT(), UINT32()).
  isComparableTo(UNTYPED_INT(), UINT64()).
  isComparableTo(UNTYPED_INT(), UINTPTR()).
  isComparableTo(UNTYPED_INT(), INT()).
  isComparableTo(UNTYPED_INT(), INT8()).
  isComparableTo(UNTYPED_INT(), INT16()).
  isComparableTo(UNTYPED_INT(), INT32()).
  isComparableTo(UNTYPED_INT(), INT64()).
  isComparableTo(UNTYPED_INT(), INTPTR()).

//  isComparableTo(T1, T2) :-
//    isNumType(T1).
//    isNumType(T2).

//  isComparableTo(T1, T2) | isNumType(T1) :-
//    isNumType(T2).

//  isComparableTo(T, UNTYPED_INT()) :-
//    isNumType(T).

  isNumType : TYPE


  // TODO: Repeat this for every possible pair?

rules isOrdered : TYPE


//rules defaultTypeOfUntypedType : TYPE -> TYPE

//  defaultTypeOfUntypedType(UNTYPED_INT)     = INT.
//  defaultTypeOfUntypedType(UNTYPED_BOOL)    = BOOL.
//  defaultTypeOfUntypedType(UNTYPED_RUNE)    = INT32.
//  defaultTypeOfUntypedType(UNTYPED_FLOAT)   = FLOAT64.
//  defaultTypeOfUntypedType(UNTYPED_COMPLEX) = COMPLEX128.
//  defaultTypeOfUntypedType(UNTYPED_STRING)  = STRING.


rules lookupType : scope * string -> TYPE

  lookupType(s, x) = T :- {dx}
    @x.ref := dx,
    typeOfDecl of Type{x} in s |-> [(_, (Type{dx}, T))].


  // TODO
//rules lookupPkg : scope * string -> PKG
//
//  lookupPkg(s, x) = P :- {dx}
//    @x.ref := dx
//    typeOfPkg of Pkg{x} in s |-> [(_, (Pkg{dx}, T))].
