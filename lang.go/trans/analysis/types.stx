module analysis/types

imports
  analysis/signatures
  // signatures/Blocks-sig
  // signatures/Declarations-sig
  // signatures/Expressions-sig
  // signatures/GoLang-sig
  // signatures/Lexical-sig
  // signatures/Packages-sig
  // signatures/Representation-sig
  // signatures/SortNames-sig
  // signatures/Statements-sig
  // signatures/Types-sig

imports
  analysis/expressions
  analysis/util
  analysis/name-resolution

signature
  sorts FAMILY
  constructors
    INT_FAMILY      : FAMILY
    FLOAT_FAMILY    : FAMILY
    COMPLEX_FAMILY  : FAMILY
    BOOL_FAMILY     : FAMILY
    STRING_FAMILY   : FAMILY
    OTHER_FAMILY    : TYPE -> FAMILY

rules familyOfType : TYPE -> FAMILY

  // UNTYPED_RUNE?
  familyOfType(UNTYPED_INT())     = INT_FAMILY().

  familyOfType(UINT())            = INT_FAMILY().
  familyOfType(UINT8())           = INT_FAMILY().
  familyOfType(UINT16())          = INT_FAMILY().
  familyOfType(UINT32())          = INT_FAMILY().
  familyOfType(UINT64())          = INT_FAMILY().
  familyOfType(UINTPTR())         = INT_FAMILY().

  familyOfType(INT())             = INT_FAMILY().
  familyOfType(INT8())            = INT_FAMILY().
  familyOfType(INT16())           = INT_FAMILY().
  familyOfType(INT32())           = INT_FAMILY().
  familyOfType(INT64())           = INT_FAMILY().
  familyOfType(INTPTR())          = INT_FAMILY().

  familyOfType(UNTYPED_FLOAT())   = FLOAT_FAMILY().
  familyOfType(FLOAT64())         = FLOAT_FAMILY().
  familyOfType(FLOAT128())        = FLOAT_FAMILY().

  familyOfType(UNTYPED_COMPLEX()) = COMPLEX_FAMILY().
  familyOfType(COMPLEX64())       = COMPLEX_FAMILY().
  familyOfType(COMPLEX128())      = COMPLEX_FAMILY().

  familyOfType(UNTYPED_BOOL())    = BOOL_FAMILY().
  familyOfType(BOOL())            = BOOL_FAMILY().

  familyOfType(UNTYPED_STRING())  = STRING_FAMILY().
  familyOfType(STRING())          = STRING_FAMILY().

  familyOfType(T)                 = OTHER_FAMILY(T).


signature
// Special types
constructors
  NAMED       : occurrence -> TYPE
  FUN         : list(TYPE) * TYPE -> TYPE
  ARRAY       : int * TYPE -> TYPE
  SLICE       : TYPE -> TYPE
  STRUCT      : scope -> TYPE
  PTR         : TYPE -> TYPE
  MAP         : TYPE * TYPE -> TYPE
  // A TUPLE type, to model Go functions with multiple return values.
  // Note that tuples don't have first-class support in Go. For example,
  // you cannot nest tuples. But this way we can distinguish between the case
  // of a function with zero, one, and multiple return values.
  // Invariants: empty and singleton tuples are not allowed; nested tuples are not allowed.
  TUPLE       : list(TYPE) -> TYPE
  // A VOID type, to model Go functions with no return value.
  VOID        : TYPE

  CHANNEL     : TYPE -> TYPE

// Untyped constant types
constructors
  UNTYPED_INT       : TYPE
  UNTYPED_BOOL      : TYPE
  UNTYPED_RUNE      : TYPE
  UNTYPED_FLOAT     : TYPE
  UNTYPED_COMPLEX   : TYPE
  UNTYPED_STRING    : TYPE

// Built-in types
constructors
  BOOL        : TYPE
  STRING      : TYPE

  UINT        : TYPE
  UINT8       : TYPE    // BYTE
  UINT16      : TYPE
  UINT32      : TYPE
  UINT64      : TYPE
  UINTPTR     : TYPE

  INT         : TYPE
  INT8        : TYPE
  INT16       : TYPE
  INT32       : TYPE    // RUNE
  INT64       : TYPE
  INTPTR      : TYPE

  FLOAT64     : TYPE
  FLOAT128    : TYPE

  COMPLEX64   : TYPE
  COMPLEX128  : TYPE


rules typeOfType : scope * Type -> TYPE

  typeOfType(s, TypeName2Type(TypeName(name))) = T :-
    lookupType(s, name) == T.

  typeOfType(s, TypeName2Type(QualifiedTypeName(QualifiedIdent(x, y)))) = T :-
    // TODO
    false | error $[typeOfType(QualifiedTypeName) not implemented.].

  typeOfType(s, PointerType(type)) = PTR(T) :-
    typeOfType(s, type) == T.

  typeOfType(s, ArrayType(lengthExpr, type)) = ARRAY(/* dummy size */ 42, T) :-
    // TODO: Evaluate constant expression lengthExpr to an int
    typeOfType(s, type) == T.

  typeOfType(s, SliceType(type)) = SLICE(T) :-
    typeOfType(s, type) == T.

  typeOfType(s, StructType(elements)) = T :-
    // TODO
    false | error $[typeOfType(StructType) not implemented.].

  typeOfType(s, FunctionType(sig)) = TFUN :-
    typeOfSignature(s, sig) == TFUN.

  typeOfType(s, InterfaceType(members)) = T :-
    // TODO
    false | error $[typeOfType(InterfaceType) not implemented.].

  typeOfType(s, MapType(keyType, elementType)) = MAP(TKEY, TELEMENT) :-
    typeOfType(s, keyType) == TKEY,
    typeOfType(s, elementType) == TELEMENT.

  typeOfType(s, BidirectionalChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(BidirectionalChannelType) not implemented.].

  typeOfType(s, SendingChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(SendingChannelType) not implemented.].

  typeOfType(s, ReceivingChannelType(type)) = T :-
    // TODO
    false | error $[typeOfType(ReceivingChannelType) not implemented.].


rules typeOfStructElement : scope * StructElement -> TYPE

  // TODO


rules typeOfSignature : scope * Signature -> TYPE

  typeOfSignature(s, Signature(parameters, result)) = FUN(TPARAMS, TRES) :-
    typesOfParameters(s, parameters) == TPARAMS,
    typeOfResult(s, result) == TRES.


rules typeOfResult : scope * Result -> TYPE

  typeOfResult(s, NoResult()) = VOID.

  typeOfResult(s, Parameters2Result(parameters)) = TUPLE(TRES) :-
    typesOfParameters(s, parameters) == TRES.

  typeOfResult(s, Type2Result(type)) = T :-
    typeOfType(s, type) == T.


rules typesOfParameters : scope * Parameters -> list(TYPE)

  typesOfParameters(s, Parameters(parameterDecls)) = TS :-
    typesOfParameterDecls(s, parameterDecls) == TS.


rules typeOfParameterDecl : scope * ParameterDecl -> TYPE

  typesOfParameterDecls maps typeOfParameterDecl(*, list(*)) = list(*)

  typeOfParameterDecl(s, ParameterDecl(_, type)) = T :-
    typeOfType(s, type) == T.

  typeOfParameterDecl(s, VariadicParameterDecl(_, type)) = T :-
    // TODO
    false | error $[typeOfParameterDecl(VariadicParameterDecl) not implemented.].


rules typeOfInterfaceTypeMember : scope * InterfaceTypeMember -> TYPE

  typeOfInterfaceTypeMember(s, MethodSpec(name, sig)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(MethodSpec) not implemented.].

  typeOfInterfaceTypeMember(s, EmbeddedInterface(typeName)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(EmbeddedInterface) not implemented.].

rules isIntType : TYPE

  isIntType(T) :-
    familyOfType(T) == INT_FAMILY().

rules isBoolType : TYPE

  isBoolType(T) :-
    familyOfType(T) == BOOL_FAMILY().

rules isArithmeticType : TYPE

  isArithmeticType(T) :- {F}
    familyOfType(T) == F,
    isArithmeticTypeFamily(F).

rules isArithmeticTypeFamily : FAMILY

  isArithmeticTypeFamily(INT_FAMILY()).
  isArithmeticTypeFamily(FLOAT_FAMILY()).
  isArithmeticTypeFamily(COMPLEX_FAMILY()).

rules isArithmeticOrStringType : TYPE

  isArithmeticOrStringType(T) :- {F}
    familyOfType(T) == F,
    isArithmeticOrStringTypeFamily(F).

rules isArithmeticOrStringTypeFamily : FAMILY

  isArithmeticOrStringTypeFamily(STRING_FAMILY()).
  isArithmeticOrStringTypeFamily(F) :- isArithmeticTypeFamily(F).

//rules isUntypedType : TYPE
//
//  isUntypedType(UNTYPED_INT()).
//  isUntypedType(UNTYPED_BOOL()).
//  isUntypedType(UNTYPED_RUNE()).
//  isUntypedType(UNTYPED_FLOAT()).
//  isUntypedType(UNTYPED_COMPLEX()).
//  isUntypedType(UNTYPED_STRING()).
//
//// Families of types that can be compared for equality
//rules isEquatableTo : FAMILY * FAMILY
//
//  isEquatableTo(BOOL_FAMILY(),    BOOL_FAMILY()).
//  isEquatableTo(INT_FAMILY(),     INT_FAMILY()).
//  isEquatableTo(FLOAT_FAMILY(),   FLOAT_FAMILY()).
//  isEquatableTo(COMPLEX_FAMILY(), COMPLEX_FAMILY()).
//  isEquatableTo(STRING_FAMILY(),  STRING_FAMILY()).
//  // TODO: pointers
//  // TODO: Channels
//  // TODO: interfaces
//  // TODO: A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x.
//  isEquatableTo(OTHER_FAMILY(T1), OTHER_FAMILY(T2)) :- T1 == T2.
//  // TODO: structs iff all their fields are comparable
//
//  isEquatableTo(OTHER_FAMILY(ARRAY(_, T1)), OTHER_FAMILY(ARRAY(_, T2))) :-
//    isEquatableTo(T1, T2).
//
//// Families of types that can be compared for order
//rules isComparable : FAMILY * FAMILY
//
//  isComparable(INT_FAMILY(),      INT_FAMILY()).
//  isComparable(FLOAT_FAMILY(),    FLOAT_FAMILY()).
//  isComparable(STRING_FAMILY(),   STRING_FAMILY()).
//  isComparable(OTHER_FAMILY(T1),  OTHER_FAMILY(T2)) :- T1 == T2.


//rules defaultTypeOfUntypedType : TYPE -> TYPE

//  defaultTypeOfUntypedType(UNTYPED_INT)     = INT.
//  defaultTypeOfUntypedType(UNTYPED_BOOL)    = BOOL.
//  defaultTypeOfUntypedType(UNTYPED_RUNE)    = INT32.
//  defaultTypeOfUntypedType(UNTYPED_FLOAT)   = FLOAT64.
//  defaultTypeOfUntypedType(UNTYPED_COMPLEX) = COMPLEX128.
//  defaultTypeOfUntypedType(UNTYPED_STRING)  = STRING.



  // TODO
//rules lookupPkg : scope * string -> PKG
//
//  lookupPkg(s, x) = P :- {dx}
//    @x.ref := dx
//    typeOfPkg of Pkg{x} in s |-> [(_, (Pkg{dx}, T))].

// Families of types that can be compared for equality
rules isEquatable : TYPE * TYPE

  isEquatable(T1, T2) :- {F1 F2}
    familyOfType(T1) == F1,
    familyOfType(T2) == F2,
    isFamilyEquatable(F1, F2).

rules isFamilyEquatable : FAMILY * FAMILY

  isFamilyEquatable(BOOL_FAMILY(),    BOOL_FAMILY()).
  isFamilyEquatable(INT_FAMILY(),     INT_FAMILY()).
  isFamilyEquatable(FLOAT_FAMILY(),   FLOAT_FAMILY()).
  isFamilyEquatable(COMPLEX_FAMILY(), COMPLEX_FAMILY()).
  isFamilyEquatable(STRING_FAMILY(),  STRING_FAMILY()).
  // TODO: pointers
  // TODO: Channels
  // TODO: interfaces
  // TODO: A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x.
  isFamilyEquatable(OTHER_FAMILY(T1), OTHER_FAMILY(T2)) :- T1 == T2.
  // TODO: structs iff all their fields are comparable

  isFamilyEquatable(OTHER_FAMILY(ARRAY(_, T1)), OTHER_FAMILY(ARRAY(_, T2))) :-
    isEquatable(T1, T2).

rules isComparable : TYPE * TYPE

  isComparable(T1, T2) :- {F1 F2}
    familyOfType(T1) == F1,
    familyOfType(T2) == F2,
    isFamilyComparable(F1, F2).

// Families of types that can be compared for order
rules isFamilyComparable : FAMILY * FAMILY

  isFamilyComparable(INT_FAMILY(),      INT_FAMILY()).
  isFamilyComparable(FLOAT_FAMILY(),    FLOAT_FAMILY()).
  isFamilyComparable(STRING_FAMILY(),   STRING_FAMILY()).
  isFamilyComparable(OTHER_FAMILY(T1),  OTHER_FAMILY(T2)) :- T1 == T2.
