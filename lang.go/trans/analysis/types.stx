module analysis/types

imports
  analysis/signatures
  // signatures/Blocks-sig
  // signatures/Declarations-sig
  // signatures/Expressions-sig
  // signatures/GoLang-sig
  // signatures/Lexical-sig
  // signatures/Packages-sig
  // signatures/Representation-sig
  // signatures/SortNames-sig
  // signatures/Statements-sig
  // signatures/Types-sig

imports
  analysis/expressions
  analysis/util
  analysis/name-resolution

signature
  sorts FAMILY
  constructors
    INT_FAMILY      : FAMILY
    FLOAT_FAMILY    : FAMILY
    COMPLEX_FAMILY  : FAMILY
    BOOL_FAMILY     : FAMILY
    STRING_FAMILY   : FAMILY
    OTHER_FAMILY    : KIND -> FAMILY

rules familyOfKind : KIND -> FAMILY

  familyOfKind(UNTYPED_BOOL())    = BOOL_FAMILY().
  familyOfKind(BOOL())            = BOOL_FAMILY().

  familyOfKind(UNTYPED_STRING())  = STRING_FAMILY().
  familyOfKind(STRING())          = STRING_FAMILY().

  // UNTYPED_RUNE?
  familyOfKind(UNTYPED_INT())     = INT_FAMILY().

  familyOfKind(INT())             = INT_FAMILY().
  familyOfKind(INT8())            = INT_FAMILY().
  familyOfKind(INT16())           = INT_FAMILY().
  familyOfKind(INT32())           = INT_FAMILY().
  familyOfKind(INT64())           = INT_FAMILY().

  familyOfKind(UINT())            = INT_FAMILY().
  familyOfKind(UINT8())           = INT_FAMILY().
  familyOfKind(UINT16())          = INT_FAMILY().
  familyOfKind(UINT32())          = INT_FAMILY().
  familyOfKind(UINT64())          = INT_FAMILY().

  familyOfKind(UNTYPED_FLOAT())   = FLOAT_FAMILY().
  familyOfKind(FLOAT32())         = FLOAT_FAMILY().
  familyOfKind(FLOAT64())         = FLOAT_FAMILY().

  familyOfKind(UNTYPED_COMPLEX()) = COMPLEX_FAMILY().
  familyOfKind(COMPLEX64())       = COMPLEX_FAMILY().
  familyOfKind(COMPLEX128())      = COMPLEX_FAMILY().

  familyOfKind(K)                 = OTHER_FAMILY(K).


signature
  sorts KIND
  constructors
    NAMED       : occurrence -> KIND
    FUN         : list(TYPE) * TYPE -> KIND
    ARRAY       : int * TYPE -> KIND
    SLICE       : TYPE -> KIND
    STRUCT      : scope -> KIND
    PTR         : TYPE -> KIND
    MAP         : TYPE * TYPE -> KIND
    // A TUPLE type, to model Go functions with multiple return values.
    // Note that tuples don't have first-class support in Go. For example,
    // you cannot nest tuples. But this way we can distinguish between the case
    // of a function with zero, one, and multiple return values.
    // Invariants: empty and singleton tuples are not allowed; nested tuples are not allowed.
    TUPLE       : list(TYPE) -> KIND
    // A VOID type, to model Go functions with no return value.
    VOID        : KIND

    CHANNEL     : TYPE -> KIND

  // Untyped constant types
  constructors
    UNTYPED_BOOL      : KIND
    UNTYPED_STRING    : KIND
    UNTYPED_RUNE      : KIND
    UNTYPED_INT       : KIND
    UNTYPED_FLOAT     : KIND
    UNTYPED_COMPLEX   : KIND

  // Built-in types
  constructors
    BOOL        : KIND
    STRING      : KIND
    ERROR       : KIND

    INT         : KIND
    INT8        : KIND
    INT16       : KIND
    INT32       : KIND    // RUNE
    INT64       : KIND

    UINT        : KIND
    UINT8       : KIND    // BYTE
    UINT16      : KIND
    UINT32      : KIND
    UINT64      : KIND
    UINTPTR     : KIND

    FLOAT32     : KIND
    FLOAT64     : KIND

    COMPLEX64   : KIND
    COMPLEX128  : KIND



/********************/
/* Underlying types */
/********************/
// Two type declarations `type T1 string` and `type T2 string` are different,
// but their underlying types are the same, `string`.
signature
  sorts TYPE
  constructors
    TYPE : string * KIND -> TYPE

//rules kindOfType : scope * Type -> KIND
//
//  kindOfType(s, type) = K :-
//    typeDeclOfType(s, type) == TYPE(_, K).



/*******************/
/* Type references */
/*******************/
rules typeOfType : scope * Type -> TYPE

  typeOfType(s, TypeName2Type(typeName)) = T :-
    typeOfTypeName(s, typeName) == T.

  // Anonymous type
  typeOfType(s, type) = TYPE("", K) :-
    kindOfType(s, type) == K.

rules typeOfTypeName : scope * TypeName -> TYPE

  typeOfTypeName(s, TypeName(name)) = T :-
    // FIXME: should be resolveType
    //resolveVar(s, name) == T.
    true.

  typeOfTypeName(s, QualifiedTypeName(x, y)) = T :-
    // TODO
    false | error $[typeOfType(QualifiedTypeName) not implemented.].

  // Anonymous type
  // FIXME: Is this correct, or should we use the keyword as the name?
  typeOfTypeName(s, typeName) = TYPE("", K) :-
    kindOfTypeName(s, typeName) == K.






// --- //

rules kindOfType : scope * Type -> KIND

  kindOfType(s, TypeName2Type(typeName)) = K :-
    kindOfTypeName(s, typeName) == K.

  kindOfType(s, PointerType(type)) = PTR(T) :-
    typeOfType(s, type) == T.

  kindOfType(s, ArrayType(lengthExpr, type)) = ARRAY(/* dummy size */ 42, T) :-
    // TODO: Evaluate constant expression lengthExpr to an int?
    typeOfType(s, type) == T.

  kindOfType(s, SliceType(type)) = SLICE(T) :-
    typeOfType(s, type) == T.

  kindOfType(s, StructType(elements)) = STRUCT(s_struct) :- {T_ELEMENTS}
    new s_struct,
//    typesOfStructElements(s_struct, elements) == T_ELEMENTS.
    false | error $[kindOfType(StructType) not implemented.].

  kindOfType(s, FunctionType(sig)) = TFUN :-
    kindOfSignature(s, sig) == TFUN.

  kindOfType(s, InterfaceType(members)) = T :-
    // TODO
    false | error $[kindOfType(InterfaceType) not implemented.].

  kindOfType(s, MapType(keyType, elementType)) = MAP(TKEY, TELEMENT) :-
    typeOfType(s, keyType) == TKEY,
    typeOfType(s, elementType) == TELEMENT.

  kindOfType(s, BidirectionalChannelType(type)) = T :-
    // TODO
    false | error $[kindOfType(BidirectionalChannelType) not implemented.].

  kindOfType(s, SendingChannelType(type)) = T :-
    // TODO
    false | error $[kindOfType(SendingChannelType) not implemented.].

  kindOfType(s, ReceivingChannelType(type)) = T :-
    // TODO
    false | error $[kindOfType(ReceivingChannelType) not implemented.].


//rules typeOfStructElement : scope * StructElement -> TYPE
//
//  typesOfStructElements maps typeOfStructElement(*, list(*)) = list(*)
//
//  typeOfStructElement(_, _) = T :-
//    true.
//
////  typeOfStructElement(s_struct, StructElement(field)) = T :-
////    typeOfField(s_struct, field) == T.
////
////  typeOfStructElement(s_struct, StructElementTagged(field, _)) = T :-
////    typeOfField(s_struct, field) == T.
rules kindOfTypeName : scope * TypeName -> KIND

  kindOfTypeName(s, TypeName(name)) = T :-
    // FIXME: should be resolveType
    //resolveVar(s, name) == T.
    true.

  kindOfTypeName(s, QualifiedTypeName(x, y)) = T :-
    // TODO
    false | error $[kindOfTypeName(QualifiedTypeName) not implemented.].

  kindOfTypeName(s, Bool()) = BOOL().
  kindOfTypeName(s, String()) = STRING().
  kindOfTypeName(s, Error()) = ERROR().

  kindOfTypeName(s, Int()) = INT().
  kindOfTypeName(s, Int8()) = INT8().
  kindOfTypeName(s, Int16()) = INT16().
  kindOfTypeName(s, Int32()) = INT32().
  kindOfTypeName(s, Int64()) = INT64().

  kindOfTypeName(s, UInt()) = UINT().
  kindOfTypeName(s, UInt8()) = UINT8().
  kindOfTypeName(s, UInt16()) = UINT16().
  kindOfTypeName(s, UInt32()) = UINT32().
  kindOfTypeName(s, UInt64()) = UINT64().
  kindOfTypeName(s, UIntPtr()) = UINTPTR().

  kindOfTypeName(s, Float32()) = FLOAT32().
  kindOfTypeName(s, Float64()) = FLOAT64().

  kindOfTypeName(s, Complex64()) = COMPLEX64().
  kindOfTypeName(s, Complex128()) = COMPLEX128().

  kindOfTypeName(s, Byte()) = UINT8().
  kindOfTypeName(s, Rune()) = INT32().


rules kindOfSignature : scope * Signature -> KIND

  kindOfSignature(s, Signature(parameters, result)) = FUN(TPARAMS, TRES) :-
    typesOfParameters(s, parameters) == TPARAMS,
    typeOfResult(s, result) == TRES.


rules typeOfResult : scope * Result -> TYPE

  typeOfResult(s, NoResult()) = VOID.

  typeOfResult(s, Parameters2Result(parameters)) = TYPE("", TUPLE(TRES)) :-
    typesOfParameters(s, parameters) == TRES.

  typeOfResult(s, Type2Result(type)) = T :-
    typeOfType(s, type) == T.


rules typesOfParameters : scope * Parameters -> list(TYPE)

  typesOfParameters(s, Parameters(parameterDecls)) = TS :-
    typesOfParameterDecls(s, parameterDecls) == TS.


rules typeOfParameterDecl : scope * ParameterDecl -> TYPE

  typesOfParameterDecls maps typeOfParameterDecl(*, list(*)) = list(*)

  typeOfParameterDecl(s, ParameterDecl(_, type)) = T :-
    typeOfType(s, type) == T.

  typeOfParameterDecl(s, VariadicParameterDecl(_, type)) = T :-
    // TODO
    false | error $[typeOfParameterDecl(VariadicParameterDecl) not implemented.].


rules typeOfInterfaceTypeMember : scope * InterfaceTypeMember -> TYPE

  typeOfInterfaceTypeMember(s, MethodSpec(name, sig)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(MethodSpec) not implemented.].

  typeOfInterfaceTypeMember(s, EmbeddedInterface(typeName)) = T :-
    // TODO
    false | error $[typeOfInterfaceTypeMember(EmbeddedInterface) not implemented.].

rules isIntType : TYPE

  isIntType(TYPE("", K)) :-
    familyOfKind(K) == INT_FAMILY().

rules isBoolType : TYPE

  isBoolType(TYPE("", K)) :-
    familyOfKind(K) == BOOL_FAMILY().

rules isArithmeticType : TYPE

  isArithmeticType(TYPE("", K)) :- {F}
    familyOfKind(K) == F,
    isArithmeticTypeFamily(F).

rules isArithmeticTypeFamily : FAMILY

  isArithmeticTypeFamily(INT_FAMILY()).
  isArithmeticTypeFamily(FLOAT_FAMILY()).
  isArithmeticTypeFamily(COMPLEX_FAMILY()).

rules isArithmeticOrStringType : TYPE

  isArithmeticOrStringType(TYPE("", K)) :- {F}
    familyOfKind(K) == F,
    isArithmeticOrStringTypeFamily(F).

rules isArithmeticOrStringTypeFamily : FAMILY

  isArithmeticOrStringTypeFamily(STRING_FAMILY()).
  isArithmeticOrStringTypeFamily(F) :- isArithmeticTypeFamily(F).

// Coerces an untyped (constant) type into a typed type
// or returns the given type when it was already typed.
rules ensureTyped : TYPE -> TYPE

  ensureTyped(TYPE("", UNTYPED_BOOL()))     = TYPE("", BOOL()).
  ensureTyped(TYPE("", UNTYPED_STRING()))   = TYPE("", STRING()).
  ensureTyped(TYPE("", UNTYPED_RUNE()))     = TYPE("", INT32()).
  ensureTyped(TYPE("", UNTYPED_INT()))      = TYPE("", INT()).
  ensureTyped(TYPE("", UNTYPED_FLOAT()))    = TYPE("", FLOAT64()).
  ensureTyped(TYPE("", UNTYPED_COMPLEX()))  = TYPE("", COMPLEX128()).
  ensureTyped(T)                            = T.

//// Fails when the given type is not an untyped (constant) type
//rules isUntyped : TYPE
//
//  isUntyped(UNTYPED_BOOL()).
//  isUntyped(UNTYPED_STRING()).
//  isUntyped(UNTYPED_RUNE()).
//  isUntyped(UNTYPED_INT()).
//  isUntyped(UNTYPED_FLOAT()).
//  isUntyped(UNTYPED_COMPLEX()).

//// Families of types that can be compared for equality
//rules isEquatableTo : FAMILY * FAMILY
//
//  isEquatableTo(BOOL_FAMILY(),    BOOL_FAMILY()).
//  isEquatableTo(INT_FAMILY(),     INT_FAMILY()).
//  isEquatableTo(FLOAT_FAMILY(),   FLOAT_FAMILY()).
//  isEquatableTo(COMPLEX_FAMILY(), COMPLEX_FAMILY()).
//  isEquatableTo(STRING_FAMILY(),  STRING_FAMILY()).
//  // TODO: pointers
//  // TODO: Channels
//  // TODO: interfaces
//  // TODO: A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x.
//  isEquatableTo(OTHER_FAMILY(T1), OTHER_FAMILY(T2)) :- T1 == T2.
//  // TODO: structs iff all their fields are comparable
//
//  isEquatableTo(OTHER_FAMILY(ARRAY(_, T1)), OTHER_FAMILY(ARRAY(_, T2))) :-
//    isEquatableTo(T1, T2).
//
//// Families of types that can be compared for order
//rules isComparable : FAMILY * FAMILY
//
//  isComparable(INT_FAMILY(),      INT_FAMILY()).
//  isComparable(FLOAT_FAMILY(),    FLOAT_FAMILY()).
//  isComparable(STRING_FAMILY(),   STRING_FAMILY()).
//  isComparable(OTHER_FAMILY(T1),  OTHER_FAMILY(T2)) :- T1 == T2.


//rules defaultTypeOfUntypedType : TYPE -> TYPE

//  defaultTypeOfUntypedType(UNTYPED_INT)     = INT.
//  defaultTypeOfUntypedType(UNTYPED_BOOL)    = BOOL.
//  defaultTypeOfUntypedType(UNTYPED_RUNE)    = INT32.
//  defaultTypeOfUntypedType(UNTYPED_FLOAT)   = FLOAT64.
//  defaultTypeOfUntypedType(UNTYPED_COMPLEX) = COMPLEX128.
//  defaultTypeOfUntypedType(UNTYPED_STRING)  = STRING.



  // TODO
//rules lookupPkg : scope * string -> PKG
//
//  lookupPkg(s, x) = P :- {dx}
//    @x.ref := dx
//    typeOfPkg of Pkg{x} in s |-> [(_, (Pkg{dx}, T))].

// Whether the left type is assignable to a variable of the right type
rules isTypeAssignableTo : TYPE * TYPE

  // Types are assignable to the same type
  isTypeAssignableTo(T, T).

  // NOTE: This is an inlining of:
  //     isTypeAssignableTo(TYPE("", T1),  TYPE(_, T2)) :-
  //       isKindAssignableTo(T1, T2).
  // which is required becuase isKindAssignableTo() cannot act as a guard for isTypeAssignableTo

  // Untyped values are assignable to anything that has a compatible type, regardless of the name:
  isTypeAssignableTo(TYPE("", UNTYPED_STRING()),  TYPE(_, STRING())).

  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, INT())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, INT8())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, INT16())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, INT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, INT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINT())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINT8())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINT16())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, UINTPTR())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, FLOAT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, FLOAT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, COMPLEX64())).
  isTypeAssignableTo(TYPE("", UNTYPED_RUNE()),    TYPE(_, COMPLEX128())).

  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, INT())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, INT8())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, INT16())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, INT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, INT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINT())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINT8())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINT16())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, UINTPTR())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, FLOAT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, FLOAT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, COMPLEX64())).
  isTypeAssignableTo(TYPE("", UNTYPED_INT()),     TYPE(_, COMPLEX128())).

  isTypeAssignableTo(TYPE("", UNTYPED_FLOAT()),   TYPE(_, FLOAT32())).
  isTypeAssignableTo(TYPE("", UNTYPED_FLOAT()),   TYPE(_, FLOAT64())).
  isTypeAssignableTo(TYPE("", UNTYPED_FLOAT()),   TYPE(_, COMPLEX64())).
  isTypeAssignableTo(TYPE("", UNTYPED_FLOAT()),   TYPE(_, COMPLEX128())).

  isTypeAssignableTo(TYPE("", UNTYPED_COMPLEX()), TYPE(_, COMPLEX64())).
  isTypeAssignableTo(TYPE("", UNTYPED_COMPLEX()), TYPE(_, COMPLEX128())).

// Whether the left kind is assignable to a variable of the right kind
rules isKindAssignableTo : KIND * KIND

  isKindAssignableTo(T, T).

  isKindAssignableTo(UNTYPED_BOOL(),    BOOL()).
  isKindAssignableTo(UNTYPED_STRING(),  STRING()).

  isKindAssignableTo(UNTYPED_RUNE(),    INT()).
  isKindAssignableTo(UNTYPED_RUNE(),    INT8()).
  isKindAssignableTo(UNTYPED_RUNE(),    INT16()).
  isKindAssignableTo(UNTYPED_RUNE(),    INT32()).
  isKindAssignableTo(UNTYPED_RUNE(),    INT64()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINT()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINT8()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINT16()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINT32()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINT64()).
  isKindAssignableTo(UNTYPED_RUNE(),    UINTPTR()).
  isKindAssignableTo(UNTYPED_RUNE(),    FLOAT32()).
  isKindAssignableTo(UNTYPED_RUNE(),    FLOAT64()).
  isKindAssignableTo(UNTYPED_RUNE(),    COMPLEX64()).
  isKindAssignableTo(UNTYPED_RUNE(),    COMPLEX128()).

  isKindAssignableTo(UNTYPED_INT(),     INT()).
  isKindAssignableTo(UNTYPED_INT(),     INT8()).
  isKindAssignableTo(UNTYPED_INT(),     INT16()).
  isKindAssignableTo(UNTYPED_INT(),     INT32()).
  isKindAssignableTo(UNTYPED_INT(),     INT64()).
  isKindAssignableTo(UNTYPED_INT(),     UINT()).
  isKindAssignableTo(UNTYPED_INT(),     UINT8()).
  isKindAssignableTo(UNTYPED_INT(),     UINT16()).
  isKindAssignableTo(UNTYPED_INT(),     UINT32()).
  isKindAssignableTo(UNTYPED_INT(),     UINT64()).
  isKindAssignableTo(UNTYPED_INT(),     UINTPTR()).
  isKindAssignableTo(UNTYPED_INT(),     FLOAT32()).
  isKindAssignableTo(UNTYPED_INT(),     FLOAT64()).
  isKindAssignableTo(UNTYPED_INT(),     COMPLEX64()).
  isKindAssignableTo(UNTYPED_INT(),     COMPLEX128()).

  isKindAssignableTo(UNTYPED_FLOAT(),   FLOAT32()).
  isKindAssignableTo(UNTYPED_FLOAT(),   FLOAT64()).
  isKindAssignableTo(UNTYPED_FLOAT(),   COMPLEX64()).
  isKindAssignableTo(UNTYPED_FLOAT(),   COMPLEX128()).

  isKindAssignableTo(UNTYPED_COMPLEX(), COMPLEX64()).
  isKindAssignableTo(UNTYPED_COMPLEX(), COMPLEX128()).


// Families of types that can be compared for equality
rules isTypeEquatable : TYPE * TYPE

  isTypeEquatable(TYPE("", K1), TYPE("", K2)) :-
    isKindEquatable(K1, K2).

// Families of kinds that can be compared for equality
rules isKindEquatable : KIND * KIND

  isKindEquatable(K1, K2) :- {F1 F2}
    familyOfKind(K1) == F1,
    familyOfKind(K2) == F2,
    isFamilyEquatable(F1, F2).

rules isFamilyEquatable : FAMILY * FAMILY

  isFamilyEquatable(BOOL_FAMILY(),    BOOL_FAMILY()).
  isFamilyEquatable(INT_FAMILY(),     INT_FAMILY()).
  isFamilyEquatable(FLOAT_FAMILY(),   FLOAT_FAMILY()).
  isFamilyEquatable(COMPLEX_FAMILY(), COMPLEX_FAMILY()).
  isFamilyEquatable(STRING_FAMILY(),  STRING_FAMILY()).
  // TODO: pointers
  // TODO: Channels
  // TODO: interfaces
  // TODO: A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x.
  isFamilyEquatable(OTHER_FAMILY(T1), OTHER_FAMILY(T2)) :- T1 == T2.
  // TODO: structs iff all their fields are comparable

  isFamilyEquatable(OTHER_FAMILY(ARRAY(_, T1)), OTHER_FAMILY(ARRAY(_, T2))) :-
    isTypeEquatable(T1, T2).

rules isTypeComparable : TYPE * TYPE

  isTypeComparable(TYPE("", K1), TYPE("", K2)) :-
    isKindComparable(K1, K2).

rules isKindComparable : KIND * KIND

  isKindComparable(K1, K2) :- {F1 F2}
    familyOfKind(K1) == F1,
    familyOfKind(K2) == F2,
    isFamilyComparable(F1, F2).

// Families of types that can be compared for order
rules isFamilyComparable : FAMILY * FAMILY

  isFamilyComparable(INT_FAMILY(),      INT_FAMILY()).
  isFamilyComparable(FLOAT_FAMILY(),    FLOAT_FAMILY()).
  isFamilyComparable(STRING_FAMILY(),   STRING_FAMILY()).
  isFamilyComparable(OTHER_FAMILY(T1),  OTHER_FAMILY(T2)) :- T1 == T2.
