module analysis/name-resolution

signature

  sorts TYPE

  namespaces
    Type    : string
    Pkg     : string
    Label   : string

  relations
    typeOfDecl  : occurrence -> TYPE
//    lblOfStmt   : occurrence

  name-resolution
    labels
      P     // lexical parent
      IMP
      PUB
      PRV
      FM

    // TODO: Is this correct?
    resolve Type  filter P* (IMP? PUB? PUB? | PRV?) FM* min $ < P, P < PRV, P < PUB, P < FM
    resolve Label filter P*                             min $ < P

rules lookupType : scope * string -> TYPE

  lookupType(s, x) = T :- {dx}
    @x.ref := dx,
    typeOfDecl of Type{x} in s |-> [(_, (Type{dx}, T))].

rules declareLabel : scope * string

  declareLabel(s, name) :-
    s -> Label{name},
    Label{name} in s |-> [(_, (Label{name}))] | error $[Multiple declarations of label [name]].

rules resolveLabel : scope * string

  resolveLabel(s, refName) :- {declName}
    Label{refName} in s |-> [(_, (Label{declName}))] | error $[Label [refName] is not declared or not in scope],
    @refName.ref := declName.


// Used to declare built-in types
rules declareTypeRaw : scope * string * TYPE

 declareTypeRaw(s, x, T) :-
   s -> Type{x} with typeOfDecl T,
   // Assert that the declaration is distinct
   typeOfDecl of Type{x} in s |-> [(_, (_, T))] | error $[Multiple declarations of type [x] : [T]].
