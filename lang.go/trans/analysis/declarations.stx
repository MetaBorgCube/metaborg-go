module analysis/declarations

imports
  analysis/signatures
  // signatures/Blocks-sig
  // signatures/Declarations-sig
  // signatures/Expressions-sig
  // signatures/GoLang-sig
  // signatures/Lexical-sig
  // signatures/Packages-sig
  // signatures/Representation-sig
  // signatures/SortNames-sig
  // signatures/Statements-sig
  // signatures/Types-sig

imports
  analysis/types
  analysis/blocks
  analysis/name-resolution

rules
  topLevelDeclsOk maps topLevelDeclOk(*, list(*))
  topLevelDeclOk : scope * TopLevelDecl

  topLevelDeclOk(s, FunctionDecl(name, sig)) :- {TFUN s_ty}
    typeOfSignature(s, sig) == TFUN,
    s -> Type{name} with typeOfDecl TFUN.

  topLevelDeclOk(s, FunctionDef(name, sig, body)) :- {TFUN s_ty}
    typeOfSignature(s, sig) == TFUN,
    s -> Type{name} with typeOfDecl TFUN,
    blockOk(s, body).

  topLevelDeclOk(s, _) :- true.

rules declarationOk : scope * Declaration

//
//rules
//  declarationOk : scope * scope * ConstDecl
//
//  declarationOk(s_decl, s, ConstDecl(constSpecELEMs)) :-
//    constSpecELEMsOk(s_decl, s, constSpecELEMs).
//
//  constSpecELEMOk : scope * scope * ConstSpec-ELEM
//  constSpecELEMsOk maps constSpecELEMOk(*, *, list(*))
//
//  constSpecELEMOk(s_decl, s, ConstSpec2ConstSpec-ELEM(constSpec)) :-
//    constSpecOk(s_decl, s, constSpec).
//
//  constSpecELEMOk(_, _, ConstSpec-ELEM-Plhdr()).
//
//rules
//  typeDeclOk : scope * scope * TypeDecl
//
//  typeDeclOk(s_decl, s, TypeDecl(typeSpecELEMs)) :-
//    typeSpecELEMsOk(s_decl, s, typeSpecELEMs).
//
//  typeDeclOk(_, _, TypeDecl-Plhdr()).
//
//rules
//  varDeclOk : scope * scope * VarDecl
//
//  varDeclOk(s_decl, s, VarDecl(varSpecELEMs)) :-
//    varSpecELEMsOk(s_decl, s, varSpecELEMs).
//
//  varDeclOk(_, _, VarDecl-Plhdr()).
//
//rules
//  constSpecOk : scope * scope * ConstSpec
//
//  constSpecOk(s_decl, s, ConstSpec(/* IDList */ names, NoType(), exprs)) :-
//    // Map1T(VarDecl)[[ names ^ (s_decl) : tys ]],
//    // Map1T[[ exprs ^ (s) : tys ]].
//    true.
//
//  constSpecOk(s_decl, s, ConstSpec(/* IDList */ names, Type2Type-OPT(type), exprs)) :-
//    // Map1t(VarDecl)[[ names ^ (s_decl) : ty ]],
//    // [[ type ^ (s, s_ty) : ty ]], new s_ty,
//    // Map1t[[ exprs ^ (s) : ty ]].
//    true.
//
//  constSpecOk(_, _, ConstSpec-Plhdr()).
//
//rules
//  typeSpecELEMOk : scope * scope * TypeSpec-ELEM
//  typeSpecELEMsOk maps typeSpecELEMOk(*, *, list(*))
//
//  typeSpecELEMOk(s_decl, s, TypeSpec2TypeSpec-ELEM(typeSpec)) :-
//    typeSpecOk(s_decl, s, typeSpec).
//
//  typeSpecELEMOk(_, _, TypeSpec-ELEM-Plhdr()).
//
//rules
//  typeSpecOk : scope * scope * TypeSpec
//
//  typeSpecOk(s_decl, s, TypeDef(name, type)) :-
//    // Type{name} <- s_decl,
//    // Type{name} : ty,
//    // new s_ty, // type scope
//    // Type{name} =FM=> s_ty,
//    // TypeFM{name} -> s,
//    // TypeFM{name} <=FM= s_ty,
//    // TopLevelType[[ type ^ (s, s_ty) : ty ]].
//    true.
//
//  // TODO:
//  typeSpecOk(s_decl, s, AliasDecl(name, type)).
//
//  typeSpecOk(_, _, TypeSpec-Plhdr()).
//
//rules
//  varSpecELEMOk : scope * scope * VarSpec-ELEM
//  varSpecELEMsOk maps varSpecELEMOk(*, *, list(*))
//
//  varSpecELEMOk(s_decl, s, VarSpec2VarSpec-ELEM(varSpec)) :-
//    varSpecOk(s_decl, s, varSpec).
//
//  varSpecELEMOk(_, _, VarSpec-ELEM-Plhdr()).
//
//rules
//  varSpecOk : scope * scope * VarSpec
//
//  varSpecOk(s_decl, s, VarSpec(/* IDList */ names, type, exprs)) :-
//    // Map1t(VarDecl)[[ names ^ (s) : ty ]],
//    // [[ type ^ (s, s_ty) : ty ]], new s_ty,
//    // Map1t(VarDecl)[[ exprs ^ (s) : ty ]].
//    true.
//
//  varSpecOk(s_decl, s, VarSpecNoType(/* IDList */ names, exprs)) :-
//    // // FIXME weird errors if lists are different length
//    // Map1T(VarDecl)[[ names ^ (s) : tys ]],
//    // Map1T[[ exprs ^ (s) : tys ]].
//    true.
//
//  varSpecOk(s_decl, s, VarSpecNoInit(/* IDList */ names, type)) :-
//    // Map1t(VarDecl)[[ names ^ (s) : ty ]],
//    // [[ type ^ (s, s_ty) : ty ]], new s_ty.
//    true.
//
//  varSpecOk(_, _, VarSpec-Plhdr()).
//
//rules
//  typeOfTopLevelType : scope * scope * TypeName -> TYPE
//
//  typeOfTopLevelType(s, s_ty, ID2TypeName(name)) = T :-
//    // Type{name} -> s,
//    // Type{name} |-> d_ty,
//    // d_ty : ty.
//    true.
//
//  typeOfTopLevelType(s, s_ty, QualifiedTypeName(QualifiedIdent(ID2PackageName(pkg), name))) = T :-
//    // Pkg{pkg} -> s,
//    // new s_qual,
//    // Pkg{pkg} <=PUB= s_qual,
//    // Type{name} -> s_qual,
//    // Type{name} |-> d_ty,
//    // d_ty : ty.
//    true.
//
//  // What does this rule do?
//  typeOfTopLevelType(s, s_ty, type) = T :-
//    // [[ type ^ (s, s_ty) : ty ]].
//    true.
//
//  typeOfTopLevelType(_, _, TypeName-Plhdr()) = _.
//
//
//rules
//  functionDeclOk : scope * scope * FunctionDecl
//
//  functionDeclOk(s_decl, s, FunctionDecl(ID2FunctionName(name), functionDeclINNER)) :-
//      // Var{name} <- s_decl,
//      // [[ function_inner ^ (s) : ty ]].
//      true.
//
//  functionDeclOk(_, _, FunctionDecl-Plhdr()).
//
//rules
//  typeOfFunctionDeclINNER : scope * FunctionDecl-INNER -> TYPE
//
//  typeOfFunctionDeclINNER(s, Signature2FunctionDecl-INNER(signature)) = T :-
//    typeOfSignature(s, signature) == T.
//  typeOfFunctionDeclINNER(s, Function2FunctionDecl-INNER(function)) = T :-
//    typeOfFunction(s, function) == T.
//
//  typeOfFunctionDeclINNER(_, FunctionDecl-INNER-Plhdr()) = _.
//
//rules
//  typeOfFunction : scope * Function -> TYPE
//
//  typeOfFunction(s, Function(sig, body)) = T :-
//      // [[ sig ^ (s) : ty ]],
//      // [[ body ^ (s_fun) ]],
//      // new s_fun,
//      // s_fun ---> s.
//      true.
//
//  typeOfFunction(_, Function-Plhdr()) = _.
//
//rules
//  functionBodyOk : scope * FunctionBody
//
//  functionBodyOk(s, Block2FunctionBody(block)) :-
//    blockOk(s, block).
//
//  functionBodyOk(_, FunctionBody-Plhdr()).
//
//rules
//  methodDeclOk : scope * scope * MethodDecl
//
//  methodDeclOk(s_decl, s, MethodDecl(Receiver(varname, ReceiverType(type@ID2TypeName(tyname))), MethodName(name), inner)) :-
//    // // method decl
//    // new s_fm,
//    // TypeFM{tyname} <- s_decl,
//    // TypeFM{tyname} =FM=> s_fm,
//    // Var{name} <- s_fm,
//    // // body
//    // new s',
//    // s' ---> s,
//    // Var{varname} <- s',
//    // [[ type ^ (s, s_ty) : ty ]], new s_ty,
//    // Var{varname} : ty,
//    // [[ inner ^ (s') : _ ]].
//    true.
//
//  methodDeclOk(s_decl, s, MethodDecl(AnonymousReceiver(ReceiverType(type@ID2TypeName(tyname))), MethodName(name), inner)) :-
//    // // method decl
//    // new s_fm,
//    // TypeFM{tyname} <- s_decl,
//    // TypeFM{tyname} =FM=> s_fm,
//    // Var{name} <- s_fm,
//    // // body
//    // new s',
//    // s' ---> s,
//    // [[ type ^ (s, s_ty) : ty ]], new s_ty,
//    // [[ inner ^ (s') ]].
//    true.
//
//  // TODO: the following are not covered
//  methodDeclOk(s_decl, s, MethodDecl(Receiver(varname, ReceiverPtrType(type@ID2TypeName(tyname))), MethodName(name), inner)).
//  methodDeclOk(s_decl, s, MethodDecl(AnonymousReceiver(ReceiverPtrType(type@ID2TypeName(tyname))), MethodName(name), inner)).
//  methodDeclOk(s_decl, s, MethodDecl(Receiver(varname, ReceiverType(type@QualifiedTypeName(QualifiedIdent(ID2PackageName(typkg), tyname)))), MethodName(name), inner)).
//  methodDeclOk(s_decl, s, MethodDecl(AnonymousReceiver(ReceiverType(type@QualifiedTypeName(QualifiedIdent(ID2PackageName(typkg), tyname)))), MethodName(name), inner)).
//  methodDeclOk(s_decl, s, MethodDecl(Receiver(varname, ReceiverPtrType(type@QualifiedTypeName(QualifiedIdent(ID2PackageName(typkg), tyname)))), MethodName(name), inner)).
//  methodDeclOk(s_decl, s, MethodDecl(AnonymousReceiver(ReceiverPtrType(type@QualifiedTypeName(QualifiedIdent(ID2PackageName(typkg), tyname)))), MethodName(name), inner)).
//
//  methodDeclOk(_, _, MethodDecl-Plhdr()).
//
//rules
//  methodDeclINNEROk : scope * MethodDecl-INNER
//
//  methodDeclINNEROk(s, Signature2MethodDecl-INNER(signature)) :- {T}
//    typeOfSignature(s, signature) == T.
//  methodDeclINNEROk(s, Function2MethodDecl-INNER(function)) :- {T}
//    typeOfFunction(s, function) == T.
//
//  methodDeclINNEROk(_, MethodDecl-INNER-Plhdr()).
