module analysis/expressions

imports
  analysis/signatures
  // signatures/Blocks-sig
  // signatures/Declarations-sig
  // signatures/Expressions-sig
  // signatures/GoLang-sig
  // signatures/Lexical-sig
  // signatures/Packages-sig
  // signatures/Representation-sig
  // signatures/SortNames-sig
  // signatures/Statements-sig
  // signatures/Types-sig

imports
  analysis/types
  analysis/declarations


//signature
//  sorts
//    CONSTVAL
//  constructors
//    CINT    : int     -> CONSTVAL
//    CSTRING : string  -> CONSTVAL
////    CONSTFLOAT  : FLOAT_LIT   -> CONSTVAL
////    CONSTSTRING : STRING_LIT  -> CONSTVAL
////    CONSTBOOL   : BOOL    -> CONSTVAL
//    CDYN    : CONSTVAL
//
//rules typeOfPrimaryExpr2 : scope * PrimaryExpr -> (TYPE * CONSTVAL)
//
//  typeOfPrimaryExpr2(s, IntLit(v))       = (UNTYPED_INT, CINT(stringToInt(v))).
//
//
//
//rules typeOfExpr2 : scope * Expr -> (TYPE * CONSTVAL)
//
//  typeOfExpr2(s, PrimaryExpr2Expr(primaryExpr)) = T :-
//    typeOfPrimaryExpr2(s, primaryExpr) == T.
//
//  typeOfExpr2(s, Sum(e1, e2)) = TV :- {TV1 TV2}
//    typeOfExpr2(s, e1) == TV1,
//    typeOfExpr2(s, e2) == TV2,
//    addConst(TV1, TV2) == TV,
//    true.

//
//rules
//  stringToInt : string -> int

//  addConst : (TYPE * CONSTVAL) * (TYPE * CONSTVAL) -> (TYPE * CONSTVAL)
//
//  addConst((T, CDYN()), (T, _)) = (T, CDYN()).
//  addConst((T, _), (T, CDYN())) = (T, CDYN()).
//  addConst((T, CINT(i)), (T, CINT(j))) = (T, CINT(i #+ j)).

  // untypedint + int = int
  // untypedint + untypedint = untypedint
  // untypedint + int8 = int8


rules typeOfExpr : scope * Expr -> TYPE

  typeOfExpr(s, IntLit(_))       = UNTYPED_INT.
  typeOfExpr(s, FloatLit(_))     = UNTYPED_FLOAT.
  typeOfExpr(s, ImaginaryLit(_)) = UNTYPED_COMPLEX.
  typeOfExpr(s, RuneLit(_))      = UNTYPED_RUNE.
  typeOfExpr(s, StringLit(_))    = UNTYPED_STRING.

  typeOfExpr(s, FunctionLit(sig, body)) = T :-
    // TODO
    true.

  typeOfExpr(s, CompositeLit(litType, litValue)) = T :-
    // TODO
    true.

  typeOfExpr(s, Index(expr, indexExpr)) = T :-
    // TODO
    true.

  typeOfExpr(s, SliceLH(expr, lowExpr, highExpr)) = T :-
    // TODO
    true.

  typeOfExpr(s, SliceLHM(expr, lowExpr, highExpr, maxExpr)) = T :-
    // TODO
    true.

  typeOfExpr(s, TypeAssertion(expr, type)) = T :-
    // TODO
    true.

  typeOfExpr(s, Call(member, arguments)) = TRETS :- {TARGS}
    typeOfArgumentsOpt(s, arguments) == TARGS,
    typeOfExpr(s, member) == FUN(TARGS, TRETS) | error $[[member] is not a method or function, or not found.].

  typeOfExpr(s, Conversion(type, expr)) = T :-
    // TODO
    true.

  typeOfExpr(s, Selector(expr, name)) = T :-
    // TODO
    true.

  typeOfExpr(s, MethodExpr(type, name)) = T :-
    // TODO
    true.

  typeOfExpr(s, OperandName(name)) = T :-
    typeOfDecl of Type{name} in s |-> [(_, (_, T))].

  typeOfExpr(s, QualifiedOperandName(QualifiedIdent(x, y))) = T :-
    // TODO
    true.

  typeOfExpr(s, CallOrConversion(name, expr)) = T :-
    // TODO
    true.

  typeOfExpr(s, QualifiedCallOrConversion(QualifiedIdent(receiver, member), expr)) = T :-
    // TODO: If receiver.member is a type, this is a type conversion (Conversion)
    // TODO: If receiver.member is a function or method, this is a call (Call)
    true.

  typeOfExpr(s, MemberAccess(receiverName, memberName)) = T :-
    // TODO
    true.


rules

  typeOfExpr(s, Positive(e)) = T :-
    typeOfExpr(s, e) == T,
    isArithmeticType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Negation(e)) = T :-
    typeOfExpr(s, e) == T,
    isArithmeticType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Not(e)) = T :-
    typeOfExpr(s, e) == T,
    isBoolType(T) | error $[Cannot do logical operations on non-bool type [T]].

  typeOfExpr(s, BitwiseComplement(e)) = T :-
    typeOfExpr(s, e) == T,
    isIntType(T) | error $[Cannot do bitwise operations on non-bool type [T]].

  typeOfExpr(s, Deref(e)) = T :-
    typeOfExpr(s, e) == PTR(T) | error $[Cannot dereference non-pointer type [T]].

  typeOfExpr(s, Ref(e)) = PTR(T) :-
    typeOfExpr(s, e) == T.
    // TODO: Verify that e is addressable: a variable, pointer indirection, slice indexing operation,
    // field selector of an addressable struct operand, or array indexing operation of an addressable array,
    // or a possibly parenthesized composite literal.
    //false | error $[Cannot create a reference to non-addressable type [T]].

  typeOfExpr(s, Receive(e)) = TE :- {T}
    typeOfExpr(s, e) == T,
    T == CHANNEL(TE) | error $[Cannot receive from non-channel type [T]].



  typeOfExpr(s, Equal(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isEquatable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].

  typeOfExpr(s, NotEqual(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isEquatable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].



  typeOfExpr(s, Less(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isComparable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].

  typeOfExpr(s, LessOrEqual(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isComparable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].

  typeOfExpr(s, Greater(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isComparable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].

  typeOfExpr(s, GreaterOrEqual(e1, e2)) = UNTYPED_BOOL :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isComparable(T1, T2) | error $[Cannot compare expressions of types [T1] and [T2].].



  typeOfExpr(s, BitwiseAnd(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isIntType(T) | error $[Cannot do bitwise operations on non-integer type [T]].

  typeOfExpr(s, BitwiseOr(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isIntType(T) | error $[Cannot do bitwise operations on non-integer type [T]].

  typeOfExpr(s, BitwiseXor(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isIntType(T) | error $[Cannot do bitwise operations on non-integer type [T]].

  typeOfExpr(s, BitClear(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isIntType(T) | error $[Cannot do bitwise operations on non-integer type [T]].



  typeOfExpr(s, LeftShift(e1, e2)) = T1 :- {T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isIntType(T1) | error $[Cannot shift non-integer type [T1]],
    isIntType(T2) | error $[Cannot shift by non-integer number of bits of type [T2]].

  typeOfExpr(s, RightShift(e1, e2)) = T1 :- {T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    isIntType(T1) | error $[Cannot shift non-integer type [T1]],
    isIntType(T2) | error $[Cannot shift by non-integer number of bits of type [T2]].



  typeOfExpr(s, Sum(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isArithmeticOrStringType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Difference(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isArithmeticType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Product(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isArithmeticType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Quotient(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isArithmeticType(T) | error $[Cannot do arithmetic operations on type [T]].

  typeOfExpr(s, Remainder(e1, e2)) = T :- {T1 T2}
    typeOfExpr(s, e1) == T1,
    typeOfExpr(s, e2) == T2,
    typeOfBinOp(T1, T2) == T,
    isIntType(T) | error $[Cannot do arithmetic operations on type [T]].


rules typeOfBinOp : TYPE * TYPE -> TYPE

  typeOfBinOp(T1, T2)                               = T :-
    // TODO: Can the types be different, e.g. subtypes of a common type?
    T1 == T2 | error $[Invalid binary operation on values of type [T1] and [T2].],
    T == T1.

  typeOfBinOp(UNTYPED_COMPLEX(), T)                 = T :-
    familyOfType(T) == COMPLEX_FAMILY() | error $[Invalid binary operation on complex constant and value of type [T].].
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_COMPLEX()) = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_FLOAT())   = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_RUNE())    = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_INT())     = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_BOOL())    = _ :-
    false | error $[Invalid binary operation on complex and bool constants.].
  typeOfBinOp(UNTYPED_COMPLEX(), UNTYPED_STRING())  = _ :-
    false | error $[Invalid binary operation on complex and string constants.].

  typeOfBinOp(UNTYPED_FLOAT(), T)                   = T :-
    familyOfType(T) == FLOAT_FAMILY() | error $[Invalid binary operation on float constant and value of type [T].].
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_COMPLEX())   = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_FLOAT())     = UNTYPED_FLOAT().
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_RUNE())      = UNTYPED_FLOAT().
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_INT())       = UNTYPED_FLOAT().
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_BOOL())      = _ :-
    false | error $[Invalid binary operation on float and bool constants.].
  typeOfBinOp(UNTYPED_FLOAT(), UNTYPED_STRING())    = _ :-
    false | error $[Invalid binary operation on float and string constants.].

  typeOfBinOp(UNTYPED_RUNE(), T)                    = T :-
    familyOfType(T) == INT_FAMILY() | error $[Invalid binary operation on rune constant and value of type [T].].
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_COMPLEX())    = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_FLOAT())      = UNTYPED_FLOAT().
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_RUNE())       = UNTYPED_RUNE().
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_INT())        = UNTYPED_RUNE().
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_BOOL())       = _ :-
    false | error $[Invalid binary operation on rune and bool constants.].
  typeOfBinOp(UNTYPED_RUNE(), UNTYPED_STRING())     = _ :-
    false | error $[Invalid binary operation on rune and string constants.].

  typeOfBinOp(UNTYPED_INT(), T)                     = T :-
    familyOfType(T) == INT_FAMILY() | error $[Invalid binary operation on int constant and value of type [T].].
  typeOfBinOp(UNTYPED_INT(), UNTYPED_COMPLEX())     = UNTYPED_COMPLEX().
  typeOfBinOp(UNTYPED_INT(), UNTYPED_FLOAT())       = UNTYPED_FLOAT().
  typeOfBinOp(UNTYPED_INT(), UNTYPED_RUNE())        = UNTYPED_RUNE().
  typeOfBinOp(UNTYPED_INT(), UNTYPED_INT())         = UNTYPED_INT().
  typeOfBinOp(UNTYPED_INT(), UNTYPED_BOOL())        = _ :-
    false | error $[Invalid binary operation on int and bool constants.].
  typeOfBinOp(UNTYPED_INT(), UNTYPED_STRING())      = _ :-
    false | error $[Invalid binary operation on int and string constants.].

  typeOfBinOp(UNTYPED_BOOL(), T)                    = T :-
    T == BOOL() | error $[Invalid binary operation on bool constant and value of type [T].].
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_COMPLEX())    = _ :-
    false | error $[Invalid binary operation on bool and complex constants.].
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_FLOAT())      = _ :-
    false | error $[Invalid binary operation on bool and float constants.].
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_RUNE())       = _ :-
    false | error $[Invalid binary operation on bool and rune constants.].
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_INT())        = _ :-
    false | error $[Invalid binary operation on bool and int constants.].
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_BOOL())       = UNTYPED_BOOL().
  typeOfBinOp(UNTYPED_BOOL(), UNTYPED_STRING())     = _ :-
    false | error $[Invalid binary operation on bool and string constants.].

  typeOfBinOp(UNTYPED_STRING(), T)                    = T :-
    T == STRING() | error $[Invalid binary operation on string constant and value of type [T].].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_COMPLEX())    = _ :-
    false | error $[Invalid binary operation on string and complex constants.].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_FLOAT())      = _ :-
    false | error $[Invalid binary operation on string and float constants.].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_RUNE())       = _ :-
    false | error $[Invalid binary operation on string and rune constants.].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_INT())        = _ :-
    false | error $[Invalid binary operation on string and int constants.].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_BOOL())       = _ :-
    false | error $[Invalid binary operation on string and bool constants.].
  typeOfBinOp(UNTYPED_STRING(), UNTYPED_STRING())     = UNTYPED_STRING().



//  typeOfExpr(s, LeftShift(lhs, rhs)) = TLHS :- {TRHS}
//    typeOfExpr(s, lhs) == TLHS,
//    /* where */ not(isUntypedType(TLHS)),
//    // TODO: Check that LHS is integer type, and RGS is integer type
//    true.



//  typeOfExpr(s, PrimaryExpr2Expr(primaryExpr)) = T :-
//    typeOfPrimaryExpr(s, primaryExpr) == T.


rules typeOfLiteralType : scope * LiteralType -> TYPE

  typeOfLiteralType(s, TypeName2LiteralType(TypeName(typeName))) = T :-
    // TODO
    true.

  typeOfLiteralType(s, TypeName2LiteralType(QualifiedTypeName(QualifiedIdent(x, y)))) = T :-
    // TODO
    true.

  typeOfLiteralType(s, StructTypeLiteral(elements)) = T :-
    // TODO
    true.

  typeOfLiteralType(s, ArrayTypeLiteral(lengthExpr, type)) = T :-
    // TODO
    true.

  typeOfLiteralType(s, AutoArrayTypeLiteral(type)) = T :-
    // TODO
    true.

  typeOfLiteralType(s, SliceTypeLiteral(type)) = T :-
    // TODO
    true.

  typeOfLiteralType(s, MapTypeLiteral(keyType, valueType)) = T :-
    // TODO
    true.


rules typeOfArgumentsOpt : scope * Arguments-OPT -> list(TYPE)
  // Each argument must be a single-valued expression;
  // or, as a special case, there can be a single argument and its multiple return values
  // are assigned as the values to the call.

  typeOfArgumentsOpt(s, NoArguments()) = [].

  typeOfArgumentsOpt(s, Arguments(ExprArguments(exprs))) = [].  // TODO
  typeOfArgumentsOpt(s, Arguments(TypeArgument(type))) = [].  // TODO
  typeOfArgumentsOpt(s, Arguments(TypedArguments(type, exprs))) = [].  // TODO

  typeOfArgumentsOpt(s, ArgumentsExplode(ExprArguments(exprs))) = [].  // TODO
  typeOfArgumentsOpt(s, ArgumentsExplode(TypeArgument(type))) = [].  // TODO
  typeOfArgumentsOpt(s, ArgumentsExplode(TypedArguments(type, exprs))) = [].  // TODO



//rules typeOfComparison : TYPE * TYPE -> TYPE
//
//  typeOfComparison(UNTYPED_INT,     UNTYPED_INT)      = UNTYPED_BOOL.
//  typeOfComparison(UNTYPED_BOOL,    UNTYPED_BOOL)     = UNTYPED_BOOL.
//  typeOfComparison(UNTYPED_RUNE,    UNTYPED_RUNE)     = UNTYPED_BOOL.
//  typeOfComparison(UNTYPED_FLOAT,   UNTYPED_FLOAT)    = UNTYPED_BOOL.
//  typeOfComparison(UNTYPED_COMPLEX, UNTYPED_COMPLEX)  = UNTYPED_BOOL.
//  typeOfComparison(UNTYPED_STRING,  UNTYPED_STRING)   = UNTYPED_BOOL.

//
//// Expressions
//rules
//  typesOfExprListOPT : scope * ExprList-OPT -> list(TYPE)
//
//  typesOfExprListOPT(s, NoExprs()) = [].
//  typesOfExprListOPT(s, ExprList2ExprList-OPT(exprList)) = TS :-
//    typesOfExprList(s, exprList) == TS.
//
//  typesOfExprListOPT(_, ExprList-OPT-Plhdr()) = _.
//
//rules
//  typesOfExprList : scope * ExprList -> list(TYPE)
//
//  typesOfExprList(s, Expr2ExprList(exprs)) = TS :-
//    typesOfExprs(s, exprs) == TS.
//
//  typesOfExprList(_, ExprList-Plhdr()) = _.
//
//rules
//  typeOfExpr : scope * Expr -> TYPE
//  typesOfExprs maps typeOfExpr(*, list(*)) = list(*)
//
//  typeOfExpr(s, UnaryExpr2Expr(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfExpr(s, BinaryExpr2Expr(expr)) = T :-
//    typeOfBinaryExpr(s, expr) == T.
//
//  typeOfExpr(_, Expr-Plhdr()) = _.
//
//
//rules
//  typeOfUnaryExpr : scope * UnaryExpr -> TYPE
//
//  typeOfUnaryExpr(s, Positive(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, Negation(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, Not(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, BitwiseComplement(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, Deref(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, Ref(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//  typeOfUnaryExpr(s, Receive(expr)) = T :-
//    typeOfUnaryExpr(s, expr) == T.
//
//  typeOfUnaryExpr(s, PrimaryExpr2UnaryExpr(expr)) = T :-
//    typeOfPrimaryExpr(s, expr) == T.
//
//rules
//  typeOfBinaryExpr : scope * BinaryExpr -> TYPE
//
//  typeOfBinaryExpr(s, LogicalOr(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, LogicalAnd(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//
//  typeOfBinaryExpr(s, Equal(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, NotEqual(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, Less(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, LessOrEqual(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, Greater(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, GreaterOrEqual(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//
//  typeOfBinaryExpr(s, Sum(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, Difference(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, BitwiseOr(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, BitwiseXor(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//
//  typeOfBinaryExpr(s, Product(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, Quotient(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, Remainder(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, LeftShift(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, RightShift(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, BitwiseAnd(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//  typeOfBinaryExpr(s, BitClear(expr1, expr2)) = T :-
//    typeOfExpr(s, expr1) == _,
//    typeOfExpr(s, expr2) == _.
//
//rules
//  typeOfPrimaryExpr : scope * PrimaryExpr -> TYPE
//
//  typeOfPrimaryExpr(s, Operand2PrimaryExpr(operand)) = T :-
//    typeOfOperand(s, operand) == T.
//  typeOfPrimaryExpr(s, Conversion2PrimaryExpr(conversion)) = T :-
//    typeOfConversion(s, conversion) == T.
//  typeOfPrimaryExpr(s, MethodExpr2PrimaryExpr(methodExpr)) = T :-
//    typeOfMethodExpr(s, methodExpr) == T.
//
//  typeOfPrimaryExpr(s, Selector(expr, name)) = T :- {TE}
//    typeOfPrimaryExpr(s, expr) == TE,
//    // TE == NamedT(d_ty), // FIXME Hardcoded for this one case
//    // d_ty ?=FM=> s_ty,
//    // new s_fld,
//    // s_fld ---> s_ty,
//    // VarRef[[ name ^ (s_fld) : ty ]],
//    // false | note "TODO: Selector/2".
//    true.
//  // TODO:
//  typeOfPrimaryExpr(s, Index(_, _)) = T.
//  typeOfPrimaryExpr(s, SliceLH(_, _, _)) = T.
//  typeOfPrimaryExpr(s, SliceLHM(_, _, _, _)) = T.
//  typeOfPrimaryExpr(s, TypeAssertion(_, _)) = T.
//  typeOfPrimaryExpr(s, Call(_, _)) = T.
//
//  typeOfPrimaryExpr(_, PrimaryExpr-Plhdr()) = _.
//
//rules
//  typeOfOperand : scope * Operand -> TYPE
//
//  typeOfOperand(s, Literal2Operand(lit)) = T :-
//    typeOfLiteral(s, lit) == T.
//
//  typeOfOperand(s, OperandName2Operand(name)) = T :-
//    typeOfOperandName(s, name) == T.
//
//  typeOfOperand(_, Operand-Plhdr()) = _.
//
//rules
//  typeOfOperandName : scope * OperandName -> TYPE
//
//  // Qualified identifiers
//  typeOfOperandName(s, OperandName(name)) = T :-
//    // Var{name} -> s,
//    // Var{name} |-> d,
//    // d : ty.
//    true.
//
//  typeOfOperandName(s, QualifiedIdent2OperandName(ident)) = T :-
//    typeOfQualifiedIdent(s, ident) == T.
//
//  typeOfOperandName(_, OperandName-Plhdr()) = _.
//
//rules
//  typeOfQualifiedIdent : scope * QualifiedIdent -> TYPE
//
//  typeOfQualifiedIdent(s, QualifiedIdent(ID2PackageName(pkg), name)) = T :-
//    // Pkg{pkg} -> s,
//    // new s_qual,
//    // Pkg{pkg} <=PUB= s_qual,
//    // Var{name} -> s_qual,
//    // Var{name} |-> d,
//    // d : ty.
//    true.
//
//  typeOfQualifiedIdent(_, QualifiedIdent-Plhdr()) = _.
//
//
//rules
//  typeOfLiteral : scope * Literal -> TYPE
//
//  typeOfLiteral(s, BasicLit2Literal(lit)) = T :-
//    typeOfBasicLit(s, lit) == T.
//  typeOfLiteral(s, CompositeLit2Literal(lit)) = T :-
//    typeOfCompositeLit(s, lit) == T.
//  typeOfLiteral(s, FunctionLit2Literal(lit)) = T :-
//    typeOfFunctionLit(s, lit) == T.
//
//  typeOfLiteral(_, Literal-Plhdr()) = _.
//
//
//rules
//  typeOfBasicLit : scope * BasicLit -> TYPE
//
//  typeOfBasicLit(s, IntLit(_)) = _.
//  typeOfBasicLit(s, FloatLit(_)) = _.
//  typeOfBasicLit(s, ImaginaryLit(_)) = _.
//  typeOfBasicLit(s, RuneLit(_)) = _.
//  typeOfBasicLit(s, StringLit(_)) = STRING().
//
//  typeOfBasicLit(_, BasicLit-Plhdr()) = _.
//
//
//rules
//  typeOfCompositeLit : scope * CompositeLit -> TYPE
//
//  typeOfCompositeLit(s, CompositeLit(type, value)) = T :- {s_ty}
//    new s_ty,
//    typeOfLiteralType(s, s_ty, type) == T,
//    typeOfLiteralValue(s, value) == _.
//
//  typeOfCompositeLit(s, CompositeLit-Plhdr()) = _.
//
//
//rules
//  typeOfFunctionLit : scope * FunctionLit -> TYPE
//
//  typeOfFunctionLit(s, FunctionLit(fun)) = T :-
//    typeOfFunction(s, fun) == _.
//
//  typeOfFunctionLit(_, FunctionLit-Plhdr()) = _.
//
//
//rules
//  typeOfConversion : scope * Conversion -> TYPE
//
//  typeOfConversion(s, Conversion(type, expr)) = T :- {s_ty}
//    new s_ty,
//    typeOfType(s, s_ty, type) == T,
//    typeOfExpr(s, expr) == _.
//
//  typeOfConversion(_, Conversion-Plhdr()) = _.
//
//rules
//  typeOfMethodExpr : scope * MethodExpr -> TYPE
//
//  // TODO:
//  typeOfMethodExpr(s, MethodExpr(_, _)) = T.
//
//  typeOfMethodExpr(_, MethodExpr-Plhdr()) = _.
//
//rules
//  typeOfArgumentsOPT : scope * Arguments-OPT -> TYPE
//
//  // TODO:
//  typeOfArgumentsOPT(s, NoArguments()) = _.
//  typeOfArgumentsOPT(s, Arguments(_)) = _.
//  typeOfArgumentsOPT(s, ArgumentsExplode(_)) = _.
//
//  typeOfArgumentsOPT(_, Arguments-OPT-Plhdr()) = _.
//
//rules
//  typeOfArguments : scope * Arguments -> TYPE
//
//  // TODO:
//  typeOfArguments(s, ExprArguments(_)) = _.
//  typeOfArguments(s, TypeArgument(_)) = _.
//  typeOfArguments(s, TypedArguments(_, _)) = _.
//
//  typeOfArguments(_, Arguments-Plhdr()) = _.
//
//  // [[ Arguments(expr,args) ^ (s) : ty ]] :=
//  //   [[ expr ^ (s) : FunT(ty_params,ty) ]],
//  //   Map1T[[ args ^ (s) : ty_args ]],
//  //   // check ty_args against ty_params
//  //   false | note "TODO: Arguments/2".
//
//rules
//  typeOfLiteralType : scope * scope * LiteralType -> TYPE
//
//  typeOfLiteralType(s, s_ty, StructType2LiteralType(structType)) = T :-
//    typeOfStructType(s, s_ty, structType) == T.
//  typeOfLiteralType(s, s_ty, ArrayType2LiteralType(arrayType)) = T :-
//    typeOfArrayType(s, s_ty, arrayType) == T.
//  typeOfLiteralType(s, s_ty, SliceType2LiteralType(sliceType)) = T :-
//    typeOfSliceType(s, s_ty, sliceType) == T.
//  typeOfLiteralType(s, s_ty, MapType2LiteralType(mapType)) = T :-
//    typeOfMapType(s, s_ty, mapType) == T.
//  typeOfLiteralType(s, s_ty, TypeName2LiteralType(typeName)) = T :-
//    typeOfTypeName(s, s_ty, typeName) == T.
//
//  // TODO:
//  typeOfLiteralType(s, s_ty, AutoArrayType(type)) = T.
//
//  typeOfLiteralType(s, s_ty, LiteralType-Plhdr()) = _.
//
//
//rules
//  typeOfLiteralValue : scope * LiteralValue -> TYPE
//
//  typeOfLiteralValue(s, LiteralValue(elemList)) = _.
//    elementListOk(s, elemList).
//
//  typeOfLiteralValue(s, LiteralValue-Plhdr()) = _.
//
//rules
//  elementListOk : scope * ElementList
//
//  elementListOk(s, KeyedElement2ElementList(elems)) :-
//    keyedElementsOk(s, elems).
//
//  elementListOk(_, ElementList-Plhdr()).
//
//rules
//  keyedElementOk : scope * KeyedElement
//  keyedElementsOk maps keyedElementOk(*, list(*))
//
//  keyedElementOk(s, KeyedElement(key, elem)) :-
//    keyOptOk(s, key),
//    elementOk(s, elem).
//
//  keyedElementOk(_, KeyedElement-Plhdr()).
//
//rules
//  keyOptOk : scope * Key-OPT
//
//  keyOptOk(s, NoKey()).
//  keyOptOk(s, Key2Key-OPT(key)) :-
//    keyOk(s, key).
//
//  keyOptOk(_, Key-OPT-Plhdr()).
//
//rules
//  keyOk : scope * Key
//
//  // TODO:
//  keyOk(s, FieldNameKey(_)).
//  keyOk(s, ExprKey(_)).
//  keyOk(s, LiteralKey(_)).
//
//  keyOk(_, Key-Plhdr()).
//
//rules
//  elementOk : scope * Element
//
//  // TODO:
//  elementOk(s, Expr2Element(expr)) :-
//    typeOfExpr(s, expr) == _.
//  elementOk(s, LiteralValue2Element(value)) :-
//    typeOfLiteralValue(s, value) == _.
//
//  elementOk(_, Element-Plhdr()).

////////////////////////////////////////////////////////////////////////////////