/**
 * Expressions -- https://golang.org/ref/spec#Expressions
 */
module Expressions

imports

  Declarations
  Lexical
  Packages
  Representation
  Types
  SortNames

context-free start-symbols

  Expr

context-free syntax

  Expr-OPT.NoExpr             = <>
  Expr-OPT                    = Expr


/**
 * Operands -- https://golang.org/ref/spec#Operands
 */
context-free sorts Operand Literal BasicLit OperandName
context-free syntax

  Operand                     = Literal
  Operand                     = OperandName
  Operand                     = <(<Expr>)>  {bracket}

  Literal                     = BasicLit
  Literal                     = CompositeLit
  Literal                     = FunctionLit

  BasicLit.IntLit             = INT_LIT
  BasicLit.FloatLit           = FLOAT_LIT
  BasicLit.ImaginaryLit       = IMAGINARY_LIT
  BasicLit.RuneLit            = RUNE_LIT
  BasicLit.StringLit          = STRING_LIT

  OperandName.OperandName     = ID
  OperandName                 = QualifiedIdent


/**
 * Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
 */
context-free sorts QualifiedIdent
context-free syntax

  QualifiedIdent.QualifiedIdent         = <<PackageName>.<ID>>
  QualifiedIdent.QualifiedIdent-DISAMB  = [[PackageName].q#[ID]]   // For manual disambiguation


/**
 * Composite literals -- https://golang.org/ref/spec#Composite_literals
 */
context-free sorts CompositeLit LiteralType LiteralValue ElementList KeyedElement Key-OPT Key FieldName Element
context-free syntax

  CompositeLit.CompositeLit   = <<LiteralType> <LiteralValue>>

  LiteralType                 = StructType
  LiteralType                 = ArrayType
  LiteralType.AutoArrayType   = <[ ... ]<ElementType>>
  LiteralType                 = SliceType
  LiteralType                 = MapType
  LiteralType                 = TypeName

  LiteralValue.LiteralValue                 = <{ <ElementList> }>
  LiteralValue.LiteralValue-ALT             = <{ <ElementList>, }>
  ElementList                               = <<{KeyedElement ","}+>>

  KeyedElement.KeyedElement   = <<Key-OPT> <Element>>

  Key-OPT.NoKey               = <>
  Key-OPT                     = Key
  Key.FieldNameKey            = <<FieldName>:>
  Key.ExprKey                 = <<Expr>:>
  Key.LiteralKey              = <<LiteralValue>:>

  FieldName                   = ID

  Element                     = Expr
  Element                     = LiteralValue


/**
 * Function literals -- https://golang.org/ref/spec#Function_literals
 */
context-free sorts FunctionLit
context-free syntax

  FunctionLit.FunctionLit     = <func <Function>>


/**
 * Primary expressions -- https://golang.org/ref/spec#Primary_expressions
 */
context-free sorts PrimaryExpr Arguments-OPT Arguments
context-free syntax

  PrimaryExpr                 = Operand
  PrimaryExpr                 = Conversion
  PrimaryExpr                 = MethodExpr

  PrimaryExpr.Selector        = <<PrimaryExpr>.<ID>> {left}               // inlined
  PrimaryExpr.Selector-DISAMB = [[PrimaryExpr].s#[ID]] {left}             // for manual disambiguation
  PrimaryExpr.Index           = <<PrimaryExpr>[<Expr>]>                   // inlined
  PrimaryExpr.SliceLH         = <<PrimaryExpr>[<Expr-OPT>:<Expr-OPT>]>		// inlined, low-high
  PrimaryExpr.SliceLHM        = <<PrimaryExpr>[<Expr-OPT>:<Expr>:<Expr>]>	// inlined, low-high-max
  PrimaryExpr.TypeAssertion   = <<PrimaryExpr>.(<Type>)>                  // inlined
  PrimaryExpr.Call            = <<PrimaryExpr>(<Arguments-OPT>)>          // inlined
  PrimaryExpr.Call-DISAMB     = [[PrimaryExpr](c#[Arguments-OPT])]        // for manual disambiguation

  Arguments-OPT.NoArguments          = <>
  Arguments-OPT.Arguments            = <<Arguments>>
  Arguments-OPT.Arguments-ALT        = <<Arguments>,>
  Arguments-OPT.ArgumentsExplode     = <<Arguments>...>
  Arguments-OPT.ArgumentsExplode-ALT = <<Arguments>... ,>
  Arguments.ExprArguments            = <<ExprList>>
  Arguments.TypeArgument             = <<Type>>
  Arguments.TypedArguments           = <<Type>, <ExprList>>


/**
 * Method expressions -- https://golang.org/ref/spec#Method_expressions
 */
context-free sorts MethodExpr ReceiverType
context-free syntax

  MethodExpr.MethodExpr         = <<ReceiverType>.<MethodName>>
  MethodExpr.MethodExpr-DISAMB  = [[ReceiverType].m#[MethodName]] // for manual disambiguation

  ReceiverType                  = Type


/**
 * Operators -- https://golang.org/ref/spec#Operators
 */
context-free sorts BinaryExpr UnaryExpr
context-free syntax

  Expr                        = UnaryExpr
  Expr                        = BinaryExpr

  // binary_op
  BinaryExpr.LogicalOr        = <<Expr> || <Expr>>  {left}
  BinaryExpr.LogicalAnd       = <<Expr> && <Expr>>  {left}

  // rel_op
  BinaryExpr.Equal            = <<Expr> == <Expr>>  {left}
  BinaryExpr.NotEqual         = <<Expr> != <Expr>>  {left}
  BinaryExpr.Less             = [[Expr] < [Expr]]   {left}
  BinaryExpr.LessOrEqual      = [[Expr] <= [Expr]]  {left}
  BinaryExpr.Greater          = [[Expr] > [Expr]]   {left}
  BinaryExpr.GreaterOrEqual   = [[Expr] >= [Expr]]  {left}

  // add_op
  BinaryExpr.Sum              = [[Expr] + [Expr]]   {left}
  BinaryExpr.Difference       = [[Expr] - [Expr]]   {left}
  BinaryExpr.BitwiseOr        = [[Expr] | [Expr]]   {left}
  BinaryExpr.BitwiseXor       = [[Expr] ^ [Expr]]   {left}

  // mul_op
  BinaryExpr.Product          = [[Expr] * [Expr]]   {left}
  BinaryExpr.Quotient         = [[Expr] / [Expr]]   {left}
  BinaryExpr.Remainder        = [[Expr] % [Expr]]   {left}
  BinaryExpr.LeftShift        = [[Expr] << [Expr]]  {left}
  BinaryExpr.RightShift       = [[Expr] >> [Expr]]  {left}
  BinaryExpr.BitwiseAnd       = [[Expr] & [Expr]]   {left}
  BinaryExpr.BitClear         = [[Expr] &^ [Expr]]  {left}


  UnaryExpr                   = PrimaryExpr
  UnaryExpr.Positive          = <+<UnaryExpr>>  {left}
  UnaryExpr.Negation          = <-<UnaryExpr>>  {left}    // Two's complement
  UnaryExpr.Not               = <!<UnaryExpr>>  {left}    // Logical complement
  UnaryExpr.BitwiseComplement = <^<UnaryExpr>>  {left}    // Ones' complement
  UnaryExpr.Deref             = <*<UnaryExpr>>  {left}
  UnaryExpr.Ref               = <&<UnaryExpr>>  {left}
  UnaryExpr.Receive           = [<-[UnaryExpr]] {left}

context-free priorities
  { left: // unary_op
    UnaryExpr.Positive
    UnaryExpr.Negation
    UnaryExpr.Not
    UnaryExpr.BitwiseComplement
    UnaryExpr.Deref
    UnaryExpr.Ref
    UnaryExpr.Receive
  } > { left: // mul_op
    BinaryExpr.Product
    BinaryExpr.Quotient
    BinaryExpr.Remainder
    BinaryExpr.LeftShift
    BinaryExpr.RightShift
    BinaryExpr.BitwiseAnd
    BinaryExpr.BitClear
  } > { left: // add_op
    BinaryExpr.Sum
    BinaryExpr.Difference
    BinaryExpr.BitwiseOr
    BinaryExpr.BitwiseXor
  } > { left: // rel_op
    BinaryExpr.Equal
    BinaryExpr.NotEqual
    BinaryExpr.Less
    BinaryExpr.LessOrEqual
    BinaryExpr.Greater
    BinaryExpr.GreaterOrEqual
  } > { left: // and_op
    BinaryExpr.LogicalAnd
  } > { left: // or_op
    BinaryExpr.LogicalOr
  }


/**
 * Conversions -- https://golang.org/ref/spec#Conversions
 */
context-free sorts Conversion
context-free syntax

  Conversion.Conversion             = <<Type>(<Expr>)>
  Conversion.Conversion-ALT         = <<Type>(<Expr>, )>
  Conversion.Conversion-DISAMB      = [[Type](t#[Expr])]    // for manual disambiguation
  Conversion.Conversion-DISAMB-ALT  = [[Type](t#[Expr], )]  // for manual disambiguation

