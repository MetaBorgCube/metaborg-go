module Expressions

imports

  Declarations
  Lexical
  Packages
  Representation
  Types

context-free start-symbols

  Expression

/**
 * Operands -- https://golang.org/ref/spec#Operands
 */
 context-free syntax
 
  PrimaryExpr = <(<Expression>)>	{bracket}
  
  PrimaryExpr.IntLit       = IntLit
  PrimaryExpr.FloatLit     = FloatLit
  PrimaryExpr.ImaginaryLit = ImaginaryLit
  PrimaryExpr.RuneLit      = RuneLit
  PrimaryExpr.StringLit    = StringLit

  PrimaryExpr.OperandName          = Identifier
  PrimaryExpr.QualifiedOperandName = QualifiedIdent


/**
 * Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
 */
context-free syntax 

  QualifiedIdent.QualifiedIdent-DISAMB = [[PackageName].q#[Identifier]]   // For manual disambiguation
  QualifiedIdent.QualifiedIdent = <<PackageName>.<Identifier>>


/**
 * Composite literals -- https://golang.org/ref/spec#Composite_literals
 */
context-free syntax 

  PrimaryExpr.CompositeLit = <<LiteralType> <LiteralValue>>

  LiteralType               = StructType
  LiteralType               = ArrayType
  LiteralType.AutoArrayType = <[ ... ]<ElementType>>
  LiteralType               = SliceType
  LiteralType               = MapType
  LiteralType               = TypeName

  LiteralValue.LiteralValue                 = <{ <KeyedElement-LIST> }>
  KeyedElement-LIST.KeyedElement-LIST-Empty = <>
  KeyedElement-LIST.KeyedElement-LIST       = <<{KeyedElement ","}+>>
  KeyedElement-LIST.KeyedElement-LIST-ALT   = <<{KeyedElement ","}+> ','>

  KeyedElement.KeyedElement        = <<Key-OPT> <Element>>

  Key-OPT.NoKey          = <>
  Key-OPT.FieldNameKey   = <<Identifier>:>
  Key-OPT.ExpressionKey  = <<Expression>:>
  Key-OPT.LiteralKey     = <<LiteralValue>:>
  
  Element            = Expression
  Element            = LiteralValue


/**
 * Function literals -- https://golang.org/ref/spec#Function_literals
 */
context-free syntax 

  PrimaryExpr.FunctionLit = <func <Function>>


/**
 * Primary expressions -- https://golang.org/ref/spec#Primary_expressions
 */
context-free syntax 

  // inlined
  PrimaryExpr.Selector-DISAMB  = [[PrimaryExpr].s#[Identifier]] {left}	// For manual disambiguation
  PrimaryExpr.Selector         = <<PrimaryExpr>.<Identifier>> {left}
  PrimaryExpr.Index            = <<PrimaryExpr>[<Expression>]>
  PrimaryExpr.SliceLH          = <<PrimaryExpr>[<Expression-OPT>:<Expression-OPT>]>				// low-high
  PrimaryExpr.SliceLHM         = <<PrimaryExpr>[<Expression-OPT>:<Expression>:<Expression>]>	// low-high-max
  PrimaryExpr.TypeAssertion    = <<PrimaryExpr>.(<Type>)>
  PrimaryExpr.Call-DISAMB      = [[PrimaryExpr](c#[Arguments-OPT])]	   // For manual disambiguation
  PrimaryExpr.Call             = <<PrimaryExpr>(<Arguments-OPT>)>
  
  Arguments-OPT.NoArguments          = <>
  Arguments-OPT.Arguments            = <<Arguments>>
  Arguments-OPT.Arguments-ALT        = <<Arguments>,>
  Arguments-OPT.ArgumentsExplode     = <<Arguments>...>
  Arguments-OPT.ArgumentsExplode-ALT = <<Arguments>... ,>
  Arguments.Arguments                = ExpressionList
  Arguments.TypeArgument             = Type
  Arguments.TypedArguments           = <<Type>, <ExpressionList>>


/**
 * Selectors -- https://golang.org/ref/spec#Selectors
 */
context-free syntax

  // no extra syntax

/**
 * Method expressions -- https://golang.org/ref/spec#Method_expressions
 */
context-free syntax

  PrimaryExpr.MethodExpr-DISAMB = [[Type].m#[MethodName]]	// For manual disambiguation
  PrimaryExpr.MethodExpr        = <<Type>.<MethodName>>
//  ReceiverType.ValueReceiver   = TypeName
//  ReceiverType.PointerReceiver = <(*<TypeName>)>
//  ReceiverType                 = <(<ReceiverType>)> {bracket}


/**
 * Method values -- https://golang.org/ref/spec#Method_values
 */
context-free syntax

  // no syntax

/**
 * Index expressions -- https://golang.org/ref/spec#Index_expressions
 */
context-free syntax

  // no syntax

/**
 * Slice expressions -- https://golang.org/ref/spec#Slice_expressions
 */
context-free syntax
 
  // no syntax

/**
 * Type assertions -- https://golang.org/ref/spec#Type_assertions
 */
context-free syntax

  // no syntax

/**
 * Calls -- https://golang.org/ref/spec#Calls
 */
context-free syntax
 
  // no syntax

/**
 * Passing arguments to ... parameters -- https://golang.org/ref/spec#Passing_arguments_to_..._parameters
 */
context-free syntax
 
  // no syntax

/**
 * Operators -- https://golang.org/ref/spec#Operators
 */
context-free syntax 

  Expression = UnaryExpr
  Expression = BinaryExpr

  Expression-OPT.NoExpression = <>
  Expression-OPT              = Expression

  // binary_op
  BinaryExpr.LogicalOr  = <<Expression> || <Expression>> {left}
  BinaryExpr.LogicalAnd = <<Expression> && <Expression>> {left}

  // rel_op
  BinaryExpr.Equal          = <<Expression> == <Expression>> {left}
  BinaryExpr.NotEqual       = <<Expression> != <Expression>> {left}
  BinaryExpr.Less           = [[Expression] < [Expression]] {left}
  BinaryExpr.LessOrEqual    = [[Expression] <= [Expression]] {left}
  BinaryExpr.Greater        = [[Expression] > [Expression]] {left}
  BinaryExpr.GreaterOrEqual = [[Expression] >= [Expression]] {left}

  // add_op
  BinaryExpr.Sum        = [[Expression] + [Expression]] {left}
  BinaryExpr.Difference = [[Expression] - [Expression]] {left}
  BinaryExpr.BitwiseOr  = [[Expression] | [Expression]] {left}
  BinaryExpr.BitwiseXor = [[Expression] ^ [Expression]] {left}

  // mul_op
  BinaryExpr.Product    = [[Expression] * [Expression]] {left}
  BinaryExpr.Quotient   = [[Expression] / [Expression]] {left}
  BinaryExpr.Remainder  = [[Expression] % [Expression]] {left}
  BinaryExpr.LeftShift  = [[Expression] << [Expression]] {left}
  BinaryExpr.RightShift = [[Expression] >> [Expression]] {left}
  BinaryExpr.BitwiseAnd = [[Expression] & [Expression]] {left}
  BinaryExpr.BitClear   = [[Expression] &^ [Expression]] {left}
  
  UnaryExpr                   = PrimaryExpr
  UnaryExpr.Positive          = <+<UnaryExpr>> {left}
  UnaryExpr.Negation          = <-<UnaryExpr>> {left}
  UnaryExpr.Not               = <!<UnaryExpr>> {left}
  UnaryExpr.BitwiseComplement = <^<UnaryExpr>> {left}
  UnaryExpr.AddressOf         = <*<UnaryExpr>> {left} // not clearly named in spec
  UnaryExpr.ValueAt           = <&<UnaryExpr>> {left} // not clearly named in spec
  UnaryExpr.Recieve           = [<-[UnaryExpr]] {left}

  context-free priorities
  { left: // unary_op
    UnaryExpr.Positive
    UnaryExpr.Negation
    UnaryExpr.Not
    UnaryExpr.BitwiseComplement
    UnaryExpr.AddressOf
    UnaryExpr.ValueAt
    UnaryExpr.Recieve
  } > { left: // mul_op
    BinaryExpr.Product
    BinaryExpr.Quotient
    BinaryExpr.Remainder
    BinaryExpr.LeftShift
    BinaryExpr.RightShift
    BinaryExpr.BitwiseAnd
    BinaryExpr.BitClear
  } > { left: // add_op
    BinaryExpr.Sum
    BinaryExpr.Difference
    BinaryExpr.BitwiseOr
    BinaryExpr.BitwiseXor
  } > { left: // rel_op
    BinaryExpr.Equal
    BinaryExpr.NotEqual
    BinaryExpr.Less
    BinaryExpr.LessOrEqual
    BinaryExpr.Greater
    BinaryExpr.GreaterOrEqual
  } > { left: // and_op
    BinaryExpr.LogicalAnd
  } > { left: // or_op
    BinaryExpr.LogicalOr
  }

/**
 * Arithemtic operators -- https://golang.org/ref/spec#Arithmetic_operators
 */
 
  // no syntax

/**
 * Comparison operators -- https://golang.org/ref/spec#Comparison_operators
 */

  // no syntax

/**
 * Logical operators -- https://golang.org/ref/spec#Logical_operators
 */
 
  // no syntax

/**
 * Address operators -- https://golang.org/ref/spec#Address_operators
 */
 
  // no syntax

/**
 * Receive operators -- https://golang.org/ref/spec#Conversions
 */
 
  // no syntax

/**
 * Conversions -- https://golang.org/ref/spec#Conversions
 */
context-free syntax 

  PrimaryExpr.Conversion-DISAMB = [[Type](t#[Expression] [Comma?])]	// For manual disambiguation
  PrimaryExpr.Conversion = <<Type>(<Expression> <Comma?>)>


/**
 * Constant expressions -- https://golang.org/ref/spec#Constant_expressions
 */
 
  // no syntax


/**
 * Order of evaluation -- https://golang.org/ref/spec#Order_of_evaluation
 */

  // no syntax
