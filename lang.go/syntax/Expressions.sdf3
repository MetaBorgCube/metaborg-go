/**
 * Expressions -- https://golang.org/ref/spec#Expressions
 */
module Expressions

imports

  Declarations
  Lexical
  Packages
  Representation
  Types
  SortNames

context-free start-symbols

  Expr

context-free syntax

  Expr-OPT.NoExpr             = <>
  Expr-OPT                    = Expr


context-free sorts PrimaryExpr
context-free syntax

  // Operands -- https://golang.org/ref/spec#Operands
  PrimaryExpr                               = <(<Expr>)>  {bracket}
  PrimaryExpr.IntLit                        = <<INT_LIT>>
  PrimaryExpr.FloatLit                      = <<FLOAT_LIT>>
  PrimaryExpr.ImaginaryLit                  = <<IMAGINARY_LIT>>
  PrimaryExpr.RuneLit                       = <<RUNE_LIT>>
  PrimaryExpr.StringLit                     = <<STRING_LIT>>
  PrimaryExpr.OperandName                   = <<ID>>

  // Function literals -- https://golang.org/ref/spec#Function_literals
  PrimaryExpr.FunctionLit                   = <func <Function>>

  // Composite literals -- https://golang.org/ref/spec#Composite_literals
  PrimaryExpr.CompositeLit                  = <<LiteralType> <LiteralValue>>

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  PrimaryExpr.Index                         = <<PrimaryExpr>[<Expr>]>
  PrimaryExpr.SliceLH                       = <<PrimaryExpr>[<Expr-OPT>:<Expr-OPT>]>    // low-high
  PrimaryExpr.SliceLHM                      = <<PrimaryExpr>[<Expr-OPT>:<Expr>:<Expr>]> // low-high-max
  PrimaryExpr.TypeAssertion                 = <<PrimaryExpr>.(<Type>)>

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  PrimaryExpr.Call                          = <<PrimaryExpr>(<Arguments-OPT>)>
  PrimaryExpr.Call-DISAMB                   = [[PrimaryExpr](c#[Arguments-OPT])]        // for manual disambiguation
  // Conversions -- https://golang.org/ref/spec#Conversions
  PrimaryExpr.Conversion                    = <<Type>(<Expr>)>
  PrimaryExpr.Conversion-ALT                = <<Type>(<Expr>, )>
  PrimaryExpr.Conversion-DISAMB             = [[Type](t#[Expr])]                        // for manual disambiguation
  PrimaryExpr.Conversion-DISAMB-ALT         = [[Type](t#[Expr], )]                      // for manual disambiguation
  // This can denote:
  // - Call: a function or method call (when receiver is an expr)
  // - Conversion: a type conversion (when receiver is a type)
  PrimaryExpr.CallOrConversion              = <<ID>(<Expr>)> {prefer}
  PrimaryExpr.CallOrConversion-ALT          = <<ID>(<Expr>, )> {prefer}

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  PrimaryExpr.Selector                      = <<PrimaryExpr>.<ID>> {left}
  PrimaryExpr.Selector-DISAMB               = [[PrimaryExpr].s#[ID]] {left}             // for manual disambiguation
  // Method expressions -- https://golang.org/ref/spec#Method_expressions
  PrimaryExpr.MethodExpr                    = <<Type>.<ID>>
  PrimaryExpr.MethodExpr-DISAMB             = [[Type].m#[ID]]                           // for manual disambiguation
  // Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
  PrimaryExpr.QualifiedOperandName          = QualifiedIdent
  // This can denote:
  // - QualifiedOperandName: a constant, variable, or function
  // - Selector: a field or method
  // - MethodExpr: a method group (when receiver is a type)
  PrimaryExpr.MemberAccess                  = <<ID>.<ID>> {left, prefer}


/*
 * Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
 */
context-free sorts QualifiedIdent
context-free syntax

  QualifiedIdent.QualifiedIdent             = <<ID>.<ID>>
  QualifiedIdent.QualifiedIdent-DISAMB      = [[ID].q#[ID]]                             // For manual disambiguation

/**
 * Composite literals -- https://golang.org/ref/spec#Composite_literals
 */
context-free sorts LiteralType LiteralValue KeyedElement Key Element
context-free syntax

  LiteralType                               = StructType
  LiteralType                               = ArrayType
  LiteralType.AutoArrayType                 = <[ ... ]<Type>>
  LiteralType                               = SliceType
  LiteralType                               = MapType
  LiteralType                               = TypeName

  LiteralValue.LiteralValue                 = <{ <{KeyedElement ","}+> }>
  LiteralValue.LiteralValue-ALT             = <{ <{KeyedElement ","}+>, }>

  KeyedElement.KeyedElement                 = <<Key> <Element>>

  Key.NoKey                                 = <>
  Key.FieldNameKey                          = <<ID>:>
  Key.ExprKey                               = <<Expr>:>
  Key.LiteralKey                            = <<LiteralValue>:>

  Element                                   = Expr
  Element                                   = LiteralValue



/**
 * Primary expressions -- https://golang.org/ref/spec#Primary_expressions
 */
context-free sorts Arguments-OPT Arguments
context-free syntax

  Arguments-OPT.NoArguments                 = <>
  Arguments-OPT.Arguments                   = <<Arguments>>
  Arguments-OPT.Arguments-ALT               = <<Arguments>,>
  Arguments-OPT.ArgumentsExplode            = <<Arguments>...>
  Arguments-OPT.ArgumentsExplode-ALT        = <<Arguments>... ,>
  Arguments.ExprArguments                   = <<ExprList>>
  Arguments.TypeArgument                    = <<Type>>
  Arguments.TypedArguments                  = <<Type>, <ExprList>>



/**
 * Operators -- https://golang.org/ref/spec#Operators
 */
context-free syntax

  // binary_op
  Expr.LogicalOr                            = <<Expr> || <Expr>>  {left}
  Expr.LogicalAnd                           = <<Expr> && <Expr>>  {left}

  // rel_op
  Expr.Equal                                = <<Expr> == <Expr>>  {left}
  Expr.NotEqual                             = <<Expr> != <Expr>>  {left}
  Expr.Less                                 = [[Expr] < [Expr]]   {left}
  Expr.LessOrEqual                          = [[Expr] <= [Expr]]  {left}
  Expr.Greater                              = [[Expr] > [Expr]]   {left}
  Expr.GreaterOrEqual                       = [[Expr] >= [Expr]]  {left}

  // add_op
  Expr.Sum                                  = [[Expr] + [Expr]]   {left}
  Expr.Difference                           = [[Expr] - [Expr]]   {left}
  Expr.BitwiseOr                            = [[Expr] | [Expr]]   {left}
  Expr.BitwiseXor                           = [[Expr] ^ [Expr]]   {left}

  // mul_op
  Expr.Product                              = [[Expr] * [Expr]]   {left}
  Expr.Quotient                             = [[Expr] / [Expr]]   {left}
  Expr.Remainder                            = [[Expr] % [Expr]]   {left}
  Expr.LeftShift                            = [[Expr] << [Expr]]  {left}
  Expr.RightShift                           = [[Expr] >> [Expr]]  {left}
  Expr.BitwiseAnd                           = [[Expr] & [Expr]]   {left}
  Expr.BitClear                             = [[Expr] &^ [Expr]]  {left}

  Expr                                      = PrimaryExpr
  Expr.Positive                             = <+<Expr>>  {left}
  Expr.Negation                             = <-<Expr>>  {left}    // Two's complement
  Expr.Not                                  = <!<Expr>>  {left}    // Logical complement
  Expr.BitwiseComplement                    = <^<Expr>>  {left}    // Ones' complement
  Expr.Deref                                = <*<Expr>>  {left}
  Expr.Ref                                  = <&<Expr>>  {left}
  Expr.Receive                              = [<-[Expr]] {left}

context-free priorities

  {
    PrimaryExpr.IntLit
    PrimaryExpr.FloatLit
    PrimaryExpr.ImaginaryLit
    PrimaryExpr.RuneLit
    PrimaryExpr.StringLit
    PrimaryExpr.OperandName
    PrimaryExpr.QualifiedOperandName
    PrimaryExpr.FunctionLit
    PrimaryExpr.CompositeLit
    PrimaryExpr.Selector
    PrimaryExpr.Selector-DISAMB
    PrimaryExpr.Index
    PrimaryExpr.SliceLH
    PrimaryExpr.SliceLHM
    PrimaryExpr.TypeAssertion
    PrimaryExpr.Call
    PrimaryExpr.Call-DISAMB
    PrimaryExpr.MethodExpr
    PrimaryExpr.MethodExpr-DISAMB
    PrimaryExpr.Conversion
    PrimaryExpr.Conversion-ALT
    PrimaryExpr.Conversion-DISAMB
    PrimaryExpr.Conversion-DISAMB-ALT
  } > { left: // unary_op
    Expr.Positive
    Expr.Negation
    Expr.Not
    Expr.BitwiseComplement
    Expr.Deref
    Expr.Ref
    Expr.Receive
  } > { left: // mul_op
    Expr.Product
    Expr.Quotient
    Expr.Remainder
    Expr.LeftShift
    Expr.RightShift
    Expr.BitwiseAnd
    Expr.BitClear
  } > { left: // add_op
    Expr.Sum
    Expr.Difference
    Expr.BitwiseOr
    Expr.BitwiseXor
  } > { left: // rel_op
    Expr.Equal
    Expr.NotEqual
    Expr.Less
    Expr.LessOrEqual
    Expr.Greater
    Expr.GreaterOrEqual
  } > { left: // and_op
    Expr.LogicalAnd
  } > { left: // or_op
    Expr.LogicalOr
  }
