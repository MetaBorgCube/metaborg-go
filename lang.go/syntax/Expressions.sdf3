/**
 * Expressions -- https://golang.org/ref/spec#Expressions
 */
module Expressions

imports

  Declarations
  Lexical
  Packages
  Representation
  Types
  SortNames

context-free start-symbols

  Expr

context-free syntax

  Expr-OPT.NoExpr                           = <>
  Expr-OPT                                  = Expr

context-free syntax

  // TODO: Support blank identifier

  // Operands -- https://golang.org/ref/spec#Operands
  Expr                                      = <(<Expr>)>  {bracket}
  Expr.IntLit                               = <<INT_LIT>>
  Expr.FloatLit                             = <<FLOAT_LIT>>
  Expr.ImaginaryLit                         = <<IMAGINARY_LIT>>
  Expr.RuneLit                              = <<RUNE_LIT>>
  Expr.StringLit                            = <<STRING_LIT>>

  // Function literals -- https://golang.org/ref/spec#Function_literals
  Expr.FunctionLit                          = <func <Signature> <Block>>

  // Composite literals -- https://golang.org/ref/spec#Composite_literals
  Expr.CompositeLit                         = <<LiteralType> <LiteralValue>>

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  Expr.Index                                = <<Expr>[<Expr>]>
  Expr.SliceLH                              = <<Expr>[<Expr-OPT>:<Expr-OPT>]>    // low-high
  Expr.SliceLHM                             = <<Expr>[<Expr-OPT>:<Expr>:<Expr>]> // low-high-max
  Expr.TypeAssertion                        = <<Expr>.(<Type>)>

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
//  Expr.Call                                 = <<Expr>(<Arguments-OPT>)>
//  Expr.Call-DISAMB                          = [[Expr](c#[Arguments-OPT])]        // for manual disambiguation
  // Conversions -- https://golang.org/ref/spec#Conversions
//  Expr.Conversion                           = <<Type>(<Expr>)>
//  Expr.Conversion-ALT                       = <<Type>(<Expr>, )>
//  Expr.Conversion-DISAMB                    = [[Type](t#[Expr])]                        // for manual disambiguation
//  Expr.Conversion-DISAMB-ALT                = [[Type](t#[Expr], )]                      // for manual disambiguation

  // Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
  Expr.OperandName                          = <<ID>>
  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  Expr.Selector                             = <<ExprOrType>.<ID>> {left}
//  Expr.Selector                             = <<Expr>.<ID>> {left}
//  Expr.Selector-DISAMB                      = [[Expr].s#[ID]] {left}             // for manual disambiguation
  // Method expressions -- https://golang.org/ref/spec#Method_expressions
//  Expr.MethodExpr                           = <<Type>.<ID>>
//  Expr.MethodExpr-DISAMB                    = [[Type].m#[ID]]                           // for manual disambiguation
//  Expr.QualifiedOperandName                 = <<ID>.<ID>>

  // This can denote:
  // - Call: a function or method call (when receiver is an expr)
  // - Conversion: a type conversion (when receiver is a type)
//  Expr.CallOrConversion                     = <<ID>(<Expr>)>
//  Expr.CallOrConversion-ALT                 = <<ID>(<Expr>, )>
//  Expr.QualifiedCallOrConversion            = <<QualifiedIdent>(<Expr>)>
//  Expr.QualifiedCallOrConversion-ALT        = <<QualifiedIdent>(<Expr>, )>

  // This can denote:
  // - QualifiedOperandName: a constant, variable, or function
  // - Selector: a field or method
  // - MethodExpr: a method group (when receiver is a type)
//  Expr.MemberAccess                         = <<ID>.<ID>> {left}//, prefer}

context-free syntax

  // Primary expressions -- https://golang.org/ref/spec#Primary_expressions
  // Conversions -- https://golang.org/ref/spec#Conversions
  // NOTE: Only the first argument can be a type in case of a call
  // NOTE: There can be only one argument in case of a conversion
  Expr.Call                                 = <<ExprOrType>(<{ExprOrType ","}*>)>
  Expr.Call-ALT                             = <<ExprOrType>(<{ExprOrType ","}*>,<>)>
  Expr.CallVariadic                         = <<ExprOrType>(<{ExprOrType ","}*>...)>
  Expr.CallVariadic-ALT                     = <<ExprOrType>(<{ExprOrType ","}*>... ,<>)>
//
//
//  Expr.CallOrConversion                     = <<ID>(<Arguments-OPT>)>
//  Expr.QualifiedCallOrConversion            = <<QualifiedIdent>(<Arguments-OPT>)>
//  Expr.Conversion                           = <<Type>(<Expr>)>
//  Expr.Conversion-ALT                       = <<Type>(<Expr>, )>
//
//  Arguments-OPT.NoArguments                 = <>
//  Arguments-OPT.Arguments                   = <<Arguments>>
//  Arguments-OPT.Arguments-ALT               = <<Arguments>,>
//  Arguments-OPT.ArgumentsExplode            = <<Arguments>...>
//  Arguments-OPT.ArgumentsExplode-ALT        = <<Arguments>... ,>
//  Arguments.ExprArguments                   = <<{ExprOrType ","}+>>
//  Arguments.TypeArgument                    = <<Type>>
//  Arguments.TypedArguments                  = <<Type>, <{Expr ","}+>>
////

context-free syntax

  ExprOrType                                = Expr
  ExprOrType                                = Type
  ExprOrType.ExprOrTypeSelector             = <<ExprOrType>.<ID>> {prefer}
  ExprOrType.ExprOrTypeName                 = <<ID>> {prefer}
  //ExprOrType.QualifiedExprOrTypeName        = <<ID>.<ID>>

context-free priorities

//  ExprOrType = Expr <0> .> Expr.OperandName,
//  ExprOrType = Expr <0> .> Expr.Selector
//  Expr.Call <0> .> Expr.OperandName,
//  Expr.Call <0> .> Expr.QualifiedOperandName,
//  Expr.Conversion <0> .> Type = TypeName


/**
 * Operators -- https://golang.org/ref/spec#Operators
 */
context-free syntax

  Expr.Positive                             = <+<Expr>>
  Expr.Negation                             = <-<Expr>>      // Two's complement
  Expr.Not                                  = <!<Expr>>      // Logical complement
  Expr.BitwiseComplement                    = <^<Expr>>      // Ones' complement
  Expr.Deref                                = <*<Expr>>
  Expr.Ref                                  = <&<Expr>>
  Expr.Receive                              = [<-[Expr]]

  Expr.Equal                                = <<Expr> == <Expr>>  {left}
  Expr.NotEqual                             = <<Expr> != <Expr>>  {left}
  Expr.Less                                 = [[Expr] < [Expr]]   {left}
  Expr.LessOrEqual                          = [[Expr] <= [Expr]]  {left}
  Expr.Greater                              = [[Expr] > [Expr]]   {left}
  Expr.GreaterOrEqual                       = [[Expr] >= [Expr]]  {left}

  Expr.LogicalOr                            = <<Expr> || <Expr>>  {left}
  Expr.LogicalAnd                           = <<Expr> && <Expr>>  {left}

  Expr.BitwiseAnd                           = [[Expr] & [Expr]]   {left}
  Expr.BitwiseOr                            = [[Expr] | [Expr]]   {left}
  Expr.BitwiseXor                           = [[Expr] ^ [Expr]]   {left}
  Expr.BitClear                             = [[Expr] &^ [Expr]]  {left}

  Expr.LeftShift                            = [[Expr] << [Expr]]  {left}
  Expr.RightShift                           = [[Expr] >> [Expr]]  {left}

  Expr.Sum                                  = [[Expr] + [Expr]]   {left}
  Expr.Difference                           = [[Expr] - [Expr]]   {left}
  Expr.Product                              = [[Expr] * [Expr]]   {left}
  Expr.Quotient                             = [[Expr] / [Expr]]   {left}
  Expr.Remainder                            = [[Expr] % [Expr]]   {left}


context-free priorities

  {
    Expr.FunctionLit
    Expr.CompositeLit
    Expr.Selector
//    Expr.Selector-DISAMB
    Expr.Index
    Expr.SliceLH
    Expr.SliceLHM
    Expr.TypeAssertion
    Expr.Call
    Expr.Call-ALT
    Expr.CallVariadic
    Expr.CallVariadic-ALT
//    Expr.MethodExpr
//    Expr.MethodExpr-DISAMB
//    Expr.Conversion
//    Expr.Conversion-ALT
//    Expr.Conversion-DISAMB
//    Expr.Conversion-DISAMB-ALT
  } > {
    Expr.Positive
    Expr.Negation
    Expr.Not
    Expr.BitwiseComplement
    Expr.Deref
    Expr.Ref
    Expr.Receive
  } > { left:
    Expr.Product
    Expr.Quotient
    Expr.Remainder
    Expr.LeftShift
    Expr.RightShift
    Expr.BitwiseAnd
    Expr.BitClear
  } > { left:
    Expr.Sum
    Expr.Difference
    Expr.BitwiseOr
    Expr.BitwiseXor
  } > { left:
    Expr.Equal
    Expr.NotEqual
    Expr.Less
    Expr.LessOrEqual
    Expr.Greater
    Expr.GreaterOrEqual
  } > { left:
    Expr.LogicalAnd
  } > { left:
    Expr.LogicalOr
  }

///*
// * Qualified identifiers -- https://golang.org/ref/spec#Qualified_identifiers
// */
//context-free sorts QualifiedIdent
//context-free syntax
//
//  QualifiedIdent.QualifiedIdent             = <<ID>.<ID>>
//  QualifiedIdent.QualifiedIdent-DISAMB      = [[ID].q#[ID]]                             // For manual disambiguation

/**
 * Composite literals -- https://golang.org/ref/spec#Composite_literals
 */
context-free sorts LiteralType LiteralValue KeyedElement Key Element
context-free syntax

  LiteralType                               = TypeName
  // Struct types -- https://golang.org/ref/spec#Struct_types
  LiteralType.StructTypeLiteral             = <struct { <StructElement*> }>
  // Array types -- https://golang.org/ref/spec#Array_types
  LiteralType.ArrayTypeLiteral              = <[<Expr>]<Type>>
  LiteralType.AutoArrayTypeLiteral          = <[ ... ]<Type>>
  // Slice types -- https://golang.org/ref/spec#Slice_types
  LiteralType.SliceTypeLiteral              = <[ ]<Type>>
  // Map types -- https://golang.org/ref/spec#Map_types
  LiteralType.MapTypeLiteral                = <map[<Type>]<Type>>

  LiteralValue.LiteralValue                 = <{ <{KeyedElement ","}*> }>
  LiteralValue.LiteralValue-ALT             = <{ <{KeyedElement ","}*>, }>

  KeyedElement.KeyedElement                 = <<Key> <Element>>

  Key.NoKey                                 = <>
  Key.FieldNameKey                          = <<ID>:>
  Key.ExprKey                               = <<Expr>:>
  Key.LiteralKey                            = <<LiteralValue>:>

  Element                                   = Expr
  Element                                   = LiteralValue



///**
// * Primary expressions -- https://golang.org/ref/spec#Primary_expressions
// */
//context-free sorts Arguments-OPT Arguments
//context-free syntax
//
//  Arguments-OPT.NoArguments                 = <>
//  Arguments-OPT.Arguments                   = <<Arguments>>
//  Arguments-OPT.Arguments-ALT               = <<Arguments>,>
//  Arguments-OPT.ArgumentsExplode            = <<Arguments>...>
//  Arguments-OPT.ArgumentsExplode-ALT        = <<Arguments>... ,>
//  Arguments.ExprArguments                   = <<{Expr ","}+>>
//  Arguments.TypeArgument                    = <<Type>>
//  Arguments.TypedArguments                  = <<Type>, <{Expr ","}+>>
//

