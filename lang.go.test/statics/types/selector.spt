module selector

language GoLang
start symbol TestSourceFiles

fixture [[
  ["."]
  package test;

  [[...]]
]]

test select field [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { [[z]] int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = t.[[z]];
]] resolve #2 to #1

test select field via anonymous field [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { [[y]] int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = t.[[y]];
]] resolve #2 to #1

test select field via anonymous pointer field [[
  type T0 struct { [[x]] int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = t.[[x]];
]] resolve #2 to #1

test select field via pointer [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { [[z]] int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[z]];
]] resolve #2 to #1

test selectfield via pointer and anonymous field [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { [[y]] int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[y]];
]] resolve #2 to #1

test select field via pointer and anonymous pointer field [[
  type T0 struct { [[x]] int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[x]];
]] resolve #2 to #1

test select field via pointer [[
  type T0 struct { [[x]] int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = q.[[x]];
]] resolve #2 to #1

test select method via anonymous pointer field [[
  type T0 struct { x int; };
  func (*T0) [[M0]]() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[M0]]();
]] resolve #2 to #1

test select method via anonymous field [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) [[M1]]() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[M1]]();
]] resolve #2 to #1

test select pointer method via pointer [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) [[M2]]() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = p.[[M2]]();
]] resolve #2 to #1

test select pointer method via value [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) [[M2]]() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = t.[[M2]]();
]] resolve #2 to #1

test select method via pointer dereference [[
  type T0 struct { x int; };
  func (*T0) [[M0]]() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = (*q).[[M0]]();
]] resolve #2 to #1

test select method via pointer fails [[
  type T0 struct { x int; };
  func (*T0) M0() {};
  type T1 struct { y int; };
  func (T1) M1() {};
  type T2 struct { z int; T1; *T0; };
  func (*T2) M2() {};
  type Q *T2;
  var t T2;     // with t.T0 != nil
  var p *T2;    // with p != nil and (*p).T0 != nil
  var q Q = p;

  var _ = q.[[M0]]();
]] > 0 errors
