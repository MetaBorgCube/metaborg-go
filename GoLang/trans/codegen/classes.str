module codegen/classes

imports

  src-gen/signatures/-
  libspoofax/stratego/debug
  codegen/-
  nabl2/api
  reference/desugar-signatures

imports // Jasmin signatures

  signatures/JasminXT-Annotations-sig
  signatures/JasminXT-Arithmetic-sig
  signatures/JasminXT-Control-sig
  signatures/JasminXT-Conversion-sig
  signatures/JasminXT-Descriptors-sig
  signatures/JasminXT-Directives-sig
  signatures/JasminXT-Exceptions-sig
  signatures/JasminXT-Fields-sig
  signatures/JasminXT-Header-sig
  signatures/JasminXT-Instructions-sig
  signatures/JasminXT-InvokeReturn-sig
  signatures/JasminXT-LoadStore-sig
  signatures/JasminXT-Methods-sig
  signatures/JasminXT-Names-sig
  signatures/JasminXT-Numbers-sig
  signatures/JasminXT-Objects-sig
  signatures/JasminXT-Stack-sig
  signatures/JasminXT-Strings-sig
  signatures/JasminXT-Synchronisation-sig
  signatures/JasminXT-Types-sig
  signatures/JasminXT-Whitespace-sig
  signatures/jasmin-sig
  reference/desugar-signatures
  analysis

rules


/*************************************************************************************
***************************************PROGRAM-TO-JBC***********************************
**************************************************************************************/ 
 
program-to-jbc : SourceFile(_,packageClause, _, functionDecls) -> 
  JBCFile(
    <package-clause-to-jbc> packageClause, 
    [],
	[JBCMethod(
		[PUBLIC()]
    	, Init()
    	, JBCMethodDesc([], Void())
    	, [ ALOAD_0()
      	, INVOKESPECIAL(
          JBCMethodRef(CRef("java/lang/Object"), MRef(Init()), JBCMethodDesc([], Void()))
        )
      	, RETURN()
  	]),
  	functions*
  	]
      	)
  	where 
  	functions* := <map(function-declaration-to-jbc) > functionDecls
  	
  
  
package-clause-to-jbc: PackageClause(packageName) ->
 	<package-name-to-jbc> packageName
 	
package-name-to-jbc: PackageName(name) ->
 JBCHeader(
    None()
  , JBCSource("")
  , JBCClass([PUBLIC()], name)
  , JBCSuper("java/lang/Object")
  , []
  , None()
  , None()
  , []
  , []
  , []
  ) 
 /*************************************************************************************
*****************************FUNCTION-DECLARATION-TO-JBC***********************************
**************************************************************************************/ 
function-declaration-to-jbc: FunctionDecl(FunctionName("main"), Function(_,block)) ->
 JBCMethod(
      [PUBLIC(), STATIC()]
    , "main"
    //TODO correct func signature
    , JBCMethodDesc([Array(Reference(CRef("java/lang/String")))], Void())
    , <concat>[[JBCLimitLocals("99")
      			, JBCLimitStack("99")],<block-to-jbc> block,[RETURN()]]
)

function-declaration-to-jbc: FunctionDecl(FunctionName(name), Function(_,block)) ->
 JBCMethod(
      [PUBLIC()]
    , name
    //TODO correct func signature
    , JBCMethodDesc([], Void()) 
    , <concat>[[JBCLimitLocals("99")
      			, JBCLimitStack("99")],<block-to-jbc> block,[RETURN()]]
)

 /*************************************************************************************
*****************************BLOCK-TO-JBC***********************************
**************************************************************************************/ 
block-to-jbc: Block(statements)->statementsResult
 where
  stackInit := [JBCLimitLocals("99")
      			, JBCLimitStack("99")];
  debug(!<concat-strings>["Block stmt-to-jbc"]);
  statementsResult :=    <map(stmt-to-jbc);concat > statements;
  output* := <concat>[stackInit,statementsResult]
  
block-to-jbc: NoBlock()->[]
 
/*************************************************************************************
*****************************STMT-TO-JBC***********************************
**************************************************************************************/ 
stmt-to-jbc: DeclarationStmt(declaration) ->
 <declaration-stmt-to-jbc> declaration
 
stmt-to-jbc: AssignStmt(toAssign,assignment) -> result
where
expressions := <map(expression-stmt-to-jbc);concat> assignment;
operands := <map(assignment-operand-to-jbc);concat> toAssign;
revertedOperands := <reverse>operands;
result :=  <concat>[expressions,revertedOperands]

assignment-operand-to-jbc:  OperandName(name) -> [result]
  where
 	a := <nabl2-get-ast-analysis> name; 
	ref-occ := <nabl2-mk-occurrence(|"Var")> name; 
	(dec-occ, _)  := <nabl2-get-resolved-name(|a)> ref-occ;
	index := <nabl2-get-property(|a, "index")> dec-occ; 
	type    := <nabl2-get-type(|a)> dec-occ;
	result := <get-store(|index)> type
 
stmt-to-jbc: ExpressionStmt(expression) ->
 <expression-stmt-to-jbc>expression
 
stmt-to-jbc: ForStmt((Condition(expression), block)) -> output*
	where
	startfor := <newname> "startfor_";
	condition := <expression-stmt-to-jbc> expression;
	debug(!<concat-strings>["condition"]) ;
	forblock := <block-to-jbc> block;
	debug(!<concat-strings>["forblock"]) ;
	endfor := <newname> "endfor_";
	output* := <concat>[
		[JBCLabel(startfor)],
		condition,
		[IFEQ(LabelRef(endfor))],
		forblock,
		[GOTO(LabelRef(startfor))],
		[JBCLabel(endfor)]];
		debug(!<concat-strings>["output"]) 
 
stmt-to-jbc: IfStmt((_, expr, ifblock, elseblock)) -> output*
	where
	ifExpression := <expression-stmt-to-jbc>expr;
	ifBlock := <block-to-jbc>ifblock;
	elseBlock := <block-to-jbc>elseblock;
	elsetrue* := <newname> "elsetrue_";
	endif* := <newname> "endif_";
	output* := <concat>[
	ifExpression,
	[IFEQ(LabelRef(elsetrue*))],
	ifBlock,
	[JBCLabel(elsetrue*)],
	elseBlock,
	[JBCLabel(endif*)]
	]
 
/*************************************************************************************
*************************EXPRESSION-STMT-TO-JBC***********************************
**************************************************************************************/ 
expression-stmt-to-jbc: Sum(x, y) -> result
where 
firstArg := <expression-stmt-to-jbc> x;
secondArg := <expression-stmt-to-jbc> y;
result := <concat>[firstArg, secondArg, [IADD()]]

expression-stmt-to-jbc: Less(x, y) -> result
where 
firstArg := <expression-stmt-to-jbc> x;
secondArg := <expression-stmt-to-jbc> y;
truelt := <newname> "trueltlabel";
falselt := <newname> "endltlabel";
result := <concat>[firstArg, secondArg, 
					[IF_ICMPLT(LabelRef(truelt)),  				
  						ICONST_0(),
  						GOTO(LabelRef(falselt)),
  						JBCLabel(truelt),
  						ICONST_1(),
  						JBCLabel(falselt)]
  					]

expression-stmt-to-jbc: ArgumentsPackage(QualifiedIdent(PackageName("fmt"), "Println"),Arguments([UnTypedArg(toPrint)])) -> [output*]
  where
   output* := <print-to-jbc> toPrint
   
   
expression-stmt-to-jbc: ArgumentsPackage(methodName,_) -> [
 	NEW(CRef("main"))	
	,DUP()					
	,INVOKESPECIAL(			
      JBCMethodRef(CRef("main"), MRef(Init()), JBCMethodDesc([], Void()))
    ),
 	INVOKEVIRTUAL(
      JBCMethodRef(
        CRef("main")
      , MRef(methodName)
      //second one is return type first one is params again
      //TODO: HANDLE ARGUMENTS AND RETURNS
      , JBCMethodDesc([], Void())
      )
    )
 ]
   
expression-stmt-to-jbc: expression -> [<literal-to-jbc> expression]
 
 //TODO: Implement return stmt
expression-stmt-to-jbc: ReturnStmt(_) -> [] 
  
expression-stmt-to-jbc:  OperandName(name) -> [result]
  where
 	a := <nabl2-get-ast-analysis> name; 
	ref-occ := <nabl2-mk-occurrence(|"Var")> name; 
	(dec-occ, _)  := <nabl2-get-resolved-name(|a)> ref-occ;
	index := <nabl2-get-property(|a, "index")> dec-occ; 
	type    := <nabl2-get-type(|a)> dec-occ;
	result := <get-load(|index)> type
	
get-load(|index): IntT ->  ILOAD(VarNum(<int-to-string>index))

get-load(|index): BoolT ->  ILOAD(VarNum(<int-to-string>index))

get-load(|index): StringT ->  ALOAD(VarNum(<int-to-string>index))
	
print-to-jbc:
toprint -> 
      [GETSTATIC(
          JBCFieldRef(
            CRef("java/lang/System") 
          , FRef("out")
          , JBCFieldDesc(Reference(CRef("java/io/PrintStream")))
          )
        )
      ,print* 
      , INVOKEVIRTUAL(
          JBCMethodRef(
            CRef("java/io/PrintStream")
          , MRef("println")
          , JBCMethodDesc([[printType*]], Void())
          )
        )
     ]
    where 
    print* := <expression-stmt-to-jbc> toprint;
    printType* := <get-print-type> toprint;
    debug
 
get-print-type: OperandName(name) -> result
 where
 	a := <nabl2-get-ast-analysis> name; 
	ref-occ := <nabl2-mk-occurrence(|"Var")> name; 
	(dec-occ, _)  := <nabl2-get-resolved-name(|a)> ref-occ;
	index := <nabl2-get-property(|a, "index")> dec-occ; 
	type    := <nabl2-get-type(|a)> dec-occ;
	result := <get-print-type> type
	
get-print-type: IntLit(_) -> Int()
 	
get-print-type: StringLit(_) -> Reference(CRef("java/lang/String"))
 
get-print-type: StringT -> Reference(CRef("java/lang/String"))
 
get-print-type: IntT -> Int()
     
/*************************************************************************************
*************************DECLARATION-STMT-TO-JBC***********************************
**************************************************************************************/ 
declaration-stmt-to-jbc: MultiVarDecl([VarSpec(names,Untyped(VarAssign(values)))]) -> result*
 where
	valueList := <map(expression-stmt-to-jbc);concat>values;
	 debug(!<concat-strings>["valuelist"]);
	varNames := <map(var-decl-to-jbc)>names;
	revertedVarNames := <reverse>varNames;
	debug(!<concat-strings>["revertedVarNames"]);
	result* := <concat>[valueList,revertedVarNames];
	debug(!<concat-strings>["result"])
 
var-decl-to-jbc: Bind(name,index) -> result*
where 
	a := <nabl2-get-ast-analysis> name; 
	ref-occ := <nabl2-mk-occurrence(|"Var")> name; 
	type    := <nabl2-get-type(|a)> ref-occ;
	result* := <get-store(|index)> type
	
get-store(|index): StringT -> ASTORE(VarNum(<int-to-string>index))

get-store(|index): IntT -> ISTORE(VarNum(<int-to-string>index))

get-store(|index): BoolT -> ISTORE(VarNum(<int-to-string>index))
  
/*************************************************************************************
*************************LITERAL-TO-JBC***********************************
**************************************************************************************/ 
literal-to-jbc: StringLit(val) ->  
 	LDC(val)
literal-to-jbc: IntLit(val) -> 
 	LDC(Int(val))
literal-to-jbc: BoolLit("false") -> 
 	LDC(Int("0"))
literal-to-jbc: BoolLit("true") -> 
 	LDC(Int("1"))
 
 
 